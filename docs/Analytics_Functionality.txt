===== FILE: client/src/pages/analytics-dashboard.tsx =====
import { useState, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Progress } from "@/components/ui/progress";
import { Separator } from "@/components/ui/separator";
import { 
  TrendingUp, 
  TrendingDown, 
  DollarSign, 
  Users, 
  Target, 
  AlertTriangle,
  BarChart3,
  LineChart,
  Activity,
  Shield,
  Zap,
  Lightbulb,
  Calendar,
  Eye,
  Bell,
  Wifi,
  WifiOff,
  Smartphone
} from "lucide-react";
import { BarChart, ResponsiveContainer, XAxis, YAxis, CartesianGrid, Tooltip, Legend, Line, Bar, Area, AreaChart, LineChart as RechartsLineChart } from "recharts";

interface AnalyticsData {
  performanceMetrics: {
    totalRevenue: number;
    revenueGrowth: number;
    userGrowth: number;
    conversionRate: number;
    customerAcquisitionCost: number;
    lifetimeValue: number;
    burnRate: number;
    runway: number;
    activeUsers: number;
    churnRate: number;
  };
  predictiveModels: {
    revenueForecasting: Array<{
      month: string;
      predicted: number;
      actual?: number;
      confidence: number;
    }>;
    userGrowthPrediction: Array<{
      month: string;
      predicted: number;
      lowerBound: number;
      upperBound: number;
    }>;
    riskFactors: Array<{
      factor: string;
      likelihood: number;
      impact: 'High' | 'Medium' | 'Low';
      mitigation: string;
    }>;
    marketOpportunities: Array<{
      opportunity: string;
      score: number;
      timeline: string;
      potential: string;
    }>;
  };
  realTimeMetrics: {
    activeUsers: number;
    salesConversions: number;
    marketSentiment: number;
    competitivePosition: number;
  };
}

interface NotificationData {
  id: string;
  title: string;
  message: string;
  type: 'success' | 'warning' | 'error' | 'info';
  timestamp: Date;
  read: boolean;
}

const COLORS = ['#8A4EF5', '#4ED0F5', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];

// Safe number formatting helpers to avoid calling toLocaleString on undefined
const formatNumber = (n?: number) => (typeof n === 'number' && isFinite(n) ? n.toLocaleString() : '0');
const formatPercent = (n?: number) => (typeof n === 'number' && isFinite(n) ? `${n}%` : '0%');

export default function AnalyticsDashboard() {
  const [selectedMetric, setSelectedMetric] = useState<string>("overview");
  const [timeRange, setTimeRange] = useState<string>("30d");
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [notifications, setNotifications] = useState<NotificationData[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);

  // Cache key for offline support
  const cacheKey = `analytics-dashboard-${timeRange}`;

  // Online/offline detection
  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  // Load cached data for offline support
  const loadCachedData = (): AnalyticsData | null => {
    try {
      const cached = localStorage.getItem(cacheKey);
      return cached ? JSON.parse(cached) : null;
    } catch {
      return null;
    }
  };

  // Save data to cache
  const saveToCache = (data: AnalyticsData) => {
    try {
      localStorage.setItem(cacheKey, JSON.stringify(data));
      localStorage.setItem(`${cacheKey}-timestamp`, Date.now().toString());
    } catch (error) {
      console.warn('Failed to cache data:', error);
    }
  };

  // Fetch analytics data with offline fallback
  const { data: analyticsData, isLoading } = useQuery<AnalyticsData>({
    queryKey: [`/api/analytics/dashboard`, timeRange],
    queryFn: async () => {
      const response = await fetch(`/api/analytics/dashboard?timeRange=${timeRange}`);
      if (!response.ok) throw new Error('Failed to fetch analytics data');
      const data = await response.json();
      saveToCache(data);
      return data;
    },
    enabled: isOnline,
    staleTime: 5 * 60 * 1000, // 5 minutes
    refetchInterval: 30000, // 30 seconds when online
  });

  // Use cached data when offline
  const data = analyticsData || loadCachedData();

  // Mock data for demonstration
  const mockData: AnalyticsData = {
    performanceMetrics: {
      totalRevenue: 485000,
      revenueGrowth: 23.5,
      userGrowth: 18.2,
      conversionRate: 12.8,
      customerAcquisitionCost: 285,
      lifetimeValue: 3450,
      burnRate: 45000,
      runway: 18.5,
      activeUsers: 12470,
      churnRate: 5.2
    },
    predictiveModels: {
      revenueForecasting: [
        { month: "Jan", predicted: 42000, actual: 41200, confidence: 0.92 },
        { month: "Feb", predicted: 46000, actual: 47800, confidence: 0.89 },
        { month: "Mar", predicted: 52000, actual: 51200, confidence: 0.91 },
        { month: "Apr", predicted: 58000, confidence: 0.87 },
        { month: "May", predicted: 64000, confidence: 0.85 },
        { month: "Jun", predicted: 72000, confidence: 0.83 }
      ],
      userGrowthPrediction: [
        { month: "Jan", predicted: 10000, lowerBound: 9500, upperBound: 10500 },
        { month: "Feb", predicted: 11500, lowerBound: 10800, upperBound: 12200 },
        { month: "Mar", predicted: 13200, lowerBound: 12300, upperBound: 14100 },
        { month: "Apr", predicted: 15100, lowerBound: 13900, upperBound: 16300 },
        { month: "May", predicted: 17200, lowerBound: 15700, upperBound: 18700 },
        { month: "Jun", predicted: 19600, lowerBound: 17800, upperBound: 21400 }
      ],
      riskFactors: [
        { factor: "Market Saturation", likelihood: 65, impact: "High", mitigation: "Expand to new markets" },
        { factor: "Competition Increase", likelihood: 78, impact: "Medium", mitigation: "Strengthen USP" },
        { factor: "Economic Downturn", likelihood: 42, impact: "High", mitigation: "Diversify revenue streams" }
      ],
      marketOpportunities: [
        { opportunity: "AI Integration", score: 89, timeline: "3-6 months", potential: "$120K ARR" },
        { opportunity: "Mobile App", score: 76, timeline: "6-9 months", potential: "$80K ARR" },
        { opportunity: "Enterprise Sales", score: 94, timeline: "2-4 months", potential: "$200K ARR" }
      ]
    },
    realTimeMetrics: {
      activeUsers: 1247,
      salesConversions: 23,
      marketSentiment: 78,
      competitivePosition: 85
    }
  };

  const currentData = data || mockData;

  // Notification management
  const addNotification = (notification: Omit<NotificationData, 'id'>) => {
    const newNotification = {
      ...notification,
      id: Date.now().toString(),
    };
    setNotifications(prev => [newNotification, ...prev.slice(0, 9)]); // Keep last 10
    setUnreadCount(prev => prev + 1);
  };

  // Generate notifications based on metrics
  useEffect(() => {
    if (!currentData?.performanceMetrics) return;

    const { performanceMetrics } = currentData;

    // Check for important updates
    if (performanceMetrics.revenueGrowth > 25) {
      addNotification({
        title: "Revenue Milestone!",
        message: `Revenue growth exceeded 25% (${performanceMetrics.revenueGrowth}%)`,
        type: 'success',
        timestamp: new Date(),
        read: false
      });
    }

    if (performanceMetrics.churnRate > 7) {
      addNotification({
        title: "High Churn Alert",
        message: `Customer churn rate is at ${performanceMetrics.churnRate}%`,
        type: 'warning',
        timestamp: new Date(),
        read: false
      });
    }

    if (performanceMetrics.runway < 12) {
      addNotification({
        title: "Low Runway Warning",
        message: `Only ${performanceMetrics.runway} months of runway remaining`,
        type: 'error',
        timestamp: new Date(),
        read: false
      });
    }
  }, [currentData?.performanceMetrics]);

  const MetricCard = ({ 
    title, 
    value, 
    change, 
    icon: Icon, 
    trend, 
    description,
    color = "blue"
  }: {
    title: string;
    value: string | number;
    change: number;
    icon: any;
    trend: "up" | "down";
    description: string;
    color?: string;
  }) => (
    <Card className="glass-card hover:shadow-lg transition-all duration-200">
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">{title}</CardTitle>
        <Icon className={`h-4 w-4 text-${color}-500`} />
      </CardHeader>
      <CardContent>
        <div className="text-2xl font-bold">{value}</div>
        <div className="flex items-center text-xs text-muted-foreground mt-1">
          {trend === 'up' ? (
            <TrendingUp className="h-3 w-3 text-green-500 mr-1" />
          ) : (
            <TrendingDown className="h-3 w-3 text-red-500 mr-1" />
          )}
          <span className={trend === 'up' ? 'text-green-500' : 'text-red-500'}>
            {Math.abs(change)}%
          </span>
          <span className="ml-1">{description}</span>
        </div>
      </CardContent>
    </Card>
  );

  const NotificationBell = () => (
    <div className="relative">
      <Button variant="ghost" size="sm" className="relative">
        <Bell className="h-4 w-4" />
        {unreadCount > 0 && (
          <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
            {unreadCount > 9 ? '9+' : unreadCount}
          </span>
        )}
      </Button>
    </div>
  );

  const RiskFactorCard = ({ factor }: { factor: typeof currentData.predictiveModels.riskFactors[0] }) => (
    <Card className="glass-card">
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle className="text-sm">{factor.factor}</CardTitle>
          <Badge variant={factor.likelihood > 70 ? "destructive" : factor.likelihood > 40 ? "secondary" : "default"}>
            {factor.likelihood}%
          </Badge>
        </div>
      </CardHeader>
      <CardContent>
        <div className="space-y-2">
          <div className="flex justify-between text-xs">
            <span>Impact:</span>
            <span className={factor.impact === "High" ? "text-red-500" : factor.impact === "Medium" ? "text-yellow-500" : "text-green-500"}>
              {factor.impact}
            </span>
          </div>
          <Progress value={factor.likelihood} className="h-2" />
          <p className="text-xs text-muted-foreground mt-2">{factor.mitigation}</p>
        </div>
      </CardContent>
    </Card>
  );

  const OpportunityCard = ({ opportunity }: { opportunity: typeof currentData.predictiveModels.marketOpportunities[0] }) => (
    <Card className="glass-card">
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle className="text-sm">{opportunity.opportunity}</CardTitle>
          <Badge variant="default" className="bg-green-100 text-green-800">
            {opportunity.score}/100
          </Badge>
        </div>
      </CardHeader>
      <CardContent>
        <div className="space-y-2">
          <div className="flex justify-between text-xs">
            <span>Timeline:</span>
            <span>{opportunity.timeline}</span>
          </div>
          <div className="flex justify-between text-xs">
            <span>Potential:</span>
            <span className="font-semibold text-green-600">{opportunity.potential}</span>
          </div>
          <Progress value={opportunity.score} className="h-2" />
        </div>
      </CardContent>
    </Card>
  );

  if (isLoading && !data) {
    return (
      <div className="container mx-auto px-4 py-8 space-y-6">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500 mx-auto mb-4"></div>
          <p>Loading analytics dashboard...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-50 via-white to-teal-50">
      <div className="container mx-auto px-4 sm:px-6 lg:px-8 py-8 space-y-6" data-testid="analytics-dashboard">
        {/* Header */}
        <div className="text-center mb-12">
          <div className="flex items-center justify-center gap-3 mb-4">
            <BarChart3 className="h-10 w-10 text-purple-600" />
            <h1 className="text-4xl md:text-5xl font-bold bg-gradient-to-r from-purple-600 to-teal-500 bg-clip-text text-transparent">
              Analytics Hub
            </h1>
            <div className="flex items-center gap-2 ml-2">
              {isOnline ? (
                <Wifi className="h-5 w-5 text-green-500" />
              ) : (
                <div className="flex items-center gap-1">
                  <WifiOff className="h-5 w-5 text-orange-500" />
                  <span className="text-xs text-orange-500">Offline</span>
                </div>
              )}
            </div>
          </div>
          <p className="text-xl text-gray-600 max-w-3xl mx-auto mb-6">
            AI-powered insights with predictive analytics and real-time metrics
          </p>
          <div className="flex items-center justify-center gap-2 flex-wrap">
          <Button 
            variant={timeRange === "7d" ? "default" : "outline"}
            size="sm"
            onClick={() => setTimeRange("7d")}
            data-testid="timerange-7d"
          >
            7D
          </Button>
          <Button 
            variant={timeRange === "30d" ? "default" : "outline"}
            size="sm"
            onClick={() => setTimeRange("30d")}
            data-testid="timerange-30d"
          >
            30D
          </Button>
          <Button 
            variant={timeRange === "90d" ? "default" : "outline"}
            size="sm"
            onClick={() => setTimeRange("90d")}
            data-testid="timerange-90d"
          >
            90D
          </Button>
        </div>
      </div>

      {/* Real-time Metrics */}
      <Card className="glass-card">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Activity className="h-5 w-5" />
            Real-time Metrics
          </CardTitle>
          <CardDescription>Live updates every 30 seconds</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
            <div className="text-center p-4 rounded-lg bg-gradient-to-br from-purple-50 to-purple-100 dark:from-purple-900/20 dark:to-purple-800/20">
              <Users className="h-6 w-6 mx-auto mb-2 text-purple-600" />
              <div className="text-2xl font-bold" data-testid="metric-active-users">{currentData.realTimeMetrics.activeUsers}</div>
              <div className="text-xs text-muted-foreground">Active Users</div>
            </div>
            <div className="text-center p-4 rounded-lg bg-gradient-to-br from-green-50 to-green-100 dark:from-green-900/20 dark:to-green-800/20">
              <Target className="h-6 w-6 mx-auto mb-2 text-green-600" />
              <div className="text-2xl font-bold" data-testid="metric-conversions">{currentData.realTimeMetrics.salesConversions}</div>
              <div className="text-xs text-muted-foreground">Conversions Today</div>
            </div>
            <div className="text-center p-4 rounded-lg bg-gradient-to-br from-blue-50 to-blue-100 dark:from-blue-900/20 dark:to-blue-800/20">
              <Eye className="h-6 w-6 mx-auto mb-2 text-blue-600" />
              <div className="text-2xl font-bold" data-testid="metric-sentiment">{currentData.realTimeMetrics.marketSentiment}%</div>
              <div className="text-xs text-muted-foreground">Market Sentiment</div>
            </div>
            <div className="text-center p-4 rounded-lg bg-gradient-to-br from-orange-50 to-orange-100 dark:from-orange-900/20 dark:to-orange-800/20">
              <Zap className="h-6 w-6 mx-auto mb-2 text-orange-600" />
              <div className="text-2xl font-bold" data-testid="metric-position">{currentData.realTimeMetrics.competitivePosition}%</div>
              <div className="text-xs text-muted-foreground">Competitive Position</div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Key Performance Indicators */}
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4">
        <MetricCard
          title="Revenue"
          value={`$${(currentData.performanceMetrics.totalRevenue / 1000).toFixed(0)}K`}
          change={currentData.performanceMetrics.revenueGrowth}
          icon={DollarSign}
          trend="up"
          description="vs last month"
          color="green"
        />
        <MetricCard
          title="Active Users"
          value={formatNumber(currentData.performanceMetrics.activeUsers)}
          change={currentData.performanceMetrics.userGrowth}
          icon={Users}
          trend="up"
          description="growth"
          color="blue"
        />
        <MetricCard
          title="Conversion"
          value={`${currentData.performanceMetrics.conversionRate}%`}
          change={2.1}
          icon={Target}
          trend="up"
          description="rate"
          color="purple"
        />
        <MetricCard
          title="Churn Rate"
          value={`${currentData.performanceMetrics.churnRate}%`}
          change={-1.2}
          icon={AlertTriangle}
          trend="down"
          description="improved"
          color="orange"
        />
        <MetricCard
          title="LTV/CAC"
          value={`${(currentData.performanceMetrics.lifetimeValue / currentData.performanceMetrics.customerAcquisitionCost).toFixed(1)}x`}
          change={8.5}
          icon={BarChart3}
          trend="up"
          description="ratio"
          color="teal"
        />
        <MetricCard
          title="Runway"
          value={`${currentData.performanceMetrics.runway}mo`}
          change={-2.1}
          icon={Calendar}
          trend="down"
          description="remaining"
          color="red"
        />
      </div>

      {/* Main Content Tabs */}
      <Tabs value={selectedMetric} onValueChange={setSelectedMetric} className="space-y-6">
        <TabsList className="grid w-full grid-cols-2 md:grid-cols-4">
          <TabsTrigger value="overview" className="flex items-center gap-1">
            <BarChart3 className="h-4 w-4" />
            <span className="hidden sm:inline">Overview</span>
          </TabsTrigger>
          <TabsTrigger value="predictions" className="flex items-center gap-1">
            <Lightbulb className="h-4 w-4" />
            <span className="hidden sm:inline">Predictions</span>
          </TabsTrigger>
          <TabsTrigger value="risks" className="flex items-center gap-1">
            <Shield className="h-4 w-4" />
            <span className="hidden sm:inline">Risk Analysis</span>
          </TabsTrigger>
          <TabsTrigger value="opportunities" className="flex items-center gap-1">
            <Target className="h-4 w-4" />
            <span className="hidden sm:inline">Opportunities</span>
          </TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-6">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* Revenue Forecasting Chart */}
            <Card className="glass-card">
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <LineChart className="h-5 w-5" />
                  Revenue Forecasting
                </CardTitle>
                <CardDescription>AI-predicted vs actual revenue trends</CardDescription>
              </CardHeader>
              <CardContent>
                <ResponsiveContainer width="100%" height={300}>
                  <AreaChart data={currentData.predictiveModels.revenueForecasting}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="month" />
                    <YAxis />
                    <Tooltip />
                    <Legend />
                    <Area type="monotone" dataKey="predicted" stackId="1" stroke="#8A4EF5" fill="#8A4EF5" fillOpacity={0.6} />
                    <Area type="monotone" dataKey="actual" stackId="2" stroke="#4ED0F5" fill="#4ED0F5" fillOpacity={0.8} />
                  </AreaChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>

            {/* User Growth Prediction */}
            <Card className="glass-card">
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Users className="h-5 w-5" />
                  User Growth Prediction
                </CardTitle>
                <CardDescription>Predicted user acquisition with confidence bands</CardDescription>
              </CardHeader>
              <CardContent>
                <ResponsiveContainer width="100%" height={300}>
                  <RechartsLineChart data={currentData.predictiveModels.userGrowthPrediction}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="month" />
                    <YAxis />
                    <Tooltip />
                    <Legend />
                    <Area 
                      type="monotone" 
                      dataKey="upperBound" 
                      stroke="#E5E7EB" 
                      fill="#E5E7EB" 
                      fillOpacity={0.3} 
                    />
                    <Area 
                      type="monotone" 
                      dataKey="lowerBound" 
                      stroke="#E5E7EB" 
                      fill="#FFFFFF" 
                      fillOpacity={1} 
                    />
                    <Line 
                      type="monotone" 
                      dataKey="predicted" 
                      stroke="#10B981" 
                      strokeWidth={2} 
                    />
                  </RechartsLineChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>
          </div>

          {/* Financial Health Overview */}
          <Card className="glass-card">
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <BarChart3 className="h-5 w-5" />
                Financial Health
              </CardTitle>
              <CardDescription>Key financial metrics and ratios</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex items-center justify-between">
                <span className="text-sm">CAC vs LTV Ratio</span>
                <div className="text-right">
                  <div className="text-lg font-semibold">1:12.1</div>
                  <div className="text-xs text-green-500">Healthy</div>
                </div>
              </div>
              <Progress value={82} className="h-2" />
              
              <Separator />
              
              <div className="flex items-center justify-between">
                <span className="text-sm">Burn Rate</span>
                <div className="text-right">
                  <div className="text-lg font-semibold">${formatNumber(currentData.performanceMetrics.burnRate)}/mo</div>
                  <div className="text-xs text-yellow-500">Monitor</div>
                </div>
              </div>
              <Progress value={65} className="h-2" />
              
              <Separator />
              
              <div className="flex items-center justify-between">
                <span className="text-sm">Growth Rate</span>
                <div className="text-right">
                  <div className="text-lg font-semibold">{currentData.performanceMetrics.revenueGrowth}%</div>
                  <div className="text-xs text-green-500">Strong</div>
                </div>
              </div>
              <Progress value={currentData.performanceMetrics.revenueGrowth * 3} className="h-2" />
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="predictions" className="space-y-6">
          <Card className="glass-card">
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Lightbulb className="h-5 w-5" />
                AI-Powered Predictions
              </CardTitle>
              <CardDescription>Machine learning insights for business planning</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div>
                  <h4 className="text-sm font-semibold mb-4">Revenue Confidence Levels</h4>
                  <ResponsiveContainer width="100%" height={250}>
                    <BarChart data={currentData.predictiveModels.revenueForecasting.map(d => ({ ...d, confidence: d.confidence * 100 }))}>
                      <CartesianGrid strokeDasharray="3 3" />
                      <XAxis dataKey="month" />
                      <YAxis domain={[0, 100]} />
                      <Tooltip formatter={(value: number) => `${value.toFixed(0)}%`} />
                      <Bar dataKey="confidence" fill="#8A4EF5" radius={[4, 4, 0, 0]} />
                    </BarChart>
                  </ResponsiveContainer>
                </div>
                
                <div>
                  <h4 className="text-sm font-semibold mb-4">Prediction Accuracy</h4>
                  <div className="space-y-3">
                    {currentData.predictiveModels.revenueForecasting
                      .filter(d => d.actual)
                      .map((item, index) => (
                        <div key={index} className="flex items-center justify-between p-3 rounded-lg bg-gray-50 dark:bg-gray-800">
                          <span className="text-sm">{item.month}</span>
                          <div className="text-right">
                            <div className="text-sm font-semibold">
                              {((1 - Math.abs(item.predicted - (item.actual || 0)) / item.predicted) * 100).toFixed(1)}% accurate
                            </div>
                            <div className="text-xs text-muted-foreground">
                              ${formatNumber(item.predicted)} vs ${item.actual ? formatNumber(item.actual) : 'N/A'}
                            </div>
                          </div>
                        </div>
                      ))}
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="risks" className="space-y-6">
          <Card className="glass-card">
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                Risk Assessment
              </CardTitle>
              <CardDescription>AI-powered risk analysis and mitigation strategies</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {currentData.predictiveModels.riskFactors.map((factor, index) => (
                  <RiskFactorCard key={index} factor={factor} />
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="opportunities" className="space-y-6">
          <Card className="glass-card">
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Target className="h-5 w-5" />
                Market Opportunities
              </CardTitle>
              <CardDescription>AI-identified growth opportunities and strategic recommendations</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {currentData.predictiveModels.marketOpportunities.map((opportunity, index) => (
                  <OpportunityCard key={index} opportunity={opportunity} />
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>

      {/* Mobile-Optimized Quick Actions */}
      <Card className="glass-card lg:hidden">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Smartphone className="h-5 w-5" />
            Quick Actions
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 gap-3">
            <Button variant="outline" size="sm" className="flex items-center gap-2">
              <BarChart3 className="h-4 w-4" />
              Reports
            </Button>
            <Button variant="outline" size="sm" className="flex items-center gap-2">
              <Bell className="h-4 w-4" />
              Alerts
            </Button>
            <Button variant="outline" size="sm" className="flex items-center gap-2">
              <Activity className="h-4 w-4" />
              Monitor
            </Button>
            <Button variant="outline" size="sm" className="flex items-center gap-2">
              <TrendingUp className="h-4 w-4" />
              Forecast
            </Button>
          </div>
        </CardContent>
      </Card>
      </div>
    </div>
  );
}

===== FILE: client/src/components/dashboard/widgets/analytics/RevenueWidget.tsx =====
import React, { memo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { 
  DollarSign, 
  TrendingUp, 
  TrendingDown,
  ArrowUpRight,
  ArrowDownRight,
  MoreHorizontal
} from 'lucide-react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { WidgetProps } from '../../types/dashboard.types';
import DashboardWidget from '../../core/DashboardWidget';

interface RevenueData {
  month: string;
  revenue: number;
  target: number;
  growth: number;
}

interface RevenueWidgetProps extends WidgetProps {
  data?: {
    current: number;
    previous: number;
    target: number;
    chartData: RevenueData[];
    currency?: string;
  };
}

const RevenueWidget: React.FC<RevenueWidgetProps> = memo(({
  widgetId,
  data,
  loading,
  error,
  onRefresh,
}) => {
  const formatCurrency = (amount: number, currency = 'USD') => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency,
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(amount);
  };

  const formatPercentage = (value: number) => {
    const sign = value >= 0 ? '+' : '';
    return `${sign}${value.toFixed(1)}%`;
  };

  const getGrowthIcon = (growth: number) => {
    if (growth > 0) return <TrendingUp className="h-4 w-4 text-green-600" />;
    if (growth < 0) return <TrendingDown className="h-4 w-4 text-red-600" />;
    return null;
  };

  const getGrowthColor = (growth: number) => {
    if (growth > 0) return 'text-green-600';
    if (growth < 0) return 'text-red-600';
    return 'text-gray-600';
  };

  if (!data) {
    return (
      <DashboardWidget
        widgetId={widgetId}
        loading={loading}
        error={error}
        onRefresh={onRefresh}
        variant="chart"
      >
        <CardContent>
          <div className="text-center text-muted-foreground">
            No revenue data available
          </div>
        </CardContent>
      </DashboardWidget>
    );
  }

  const growth = data.previous > 0 
    ? ((data.current - data.previous) / data.previous) * 100 
    : 0;

  const targetProgress = data.target > 0 
    ? (data.current / data.target) * 100 
    : 0;

  return (
    <DashboardWidget
      widgetId={widgetId}
      loading={loading}
      error={error}
      onRefresh={onRefresh}
      variant="chart"
    >
      <CardHeader className="pb-3">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-2">
            <div className="p-2 bg-green-100 rounded-lg">
              <DollarSign className="h-5 w-5 text-green-600" />
            </div>
            <div>
              <CardTitle className="text-lg">Revenue</CardTitle>
              <p className="text-sm text-muted-foreground">
                {formatCurrency(data.current, data.currency)}
              </p>
            </div>
          </div>
          <div className="flex items-center space-x-2">
            {getGrowthIcon(growth)}
            <span className={`text-sm font-medium ${getGrowthColor(growth)}`}>
              {formatPercentage(growth)}
            </span>
          </div>
        </div>
      </CardHeader>

      <CardContent className="space-y-4">
        {/* Key Metrics */}
        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-1">
            <p className="text-sm text-muted-foreground">Target</p>
            <p className="text-lg font-semibold">
              {formatCurrency(data.target, data.currency)}
            </p>
          </div>
          <div className="space-y-1">
            <p className="text-sm text-muted-foreground">Progress</p>
            <div className="flex items-center space-x-2">
              <div className="flex-1 bg-gray-200 rounded-full h-2">
                <div 
                  className="bg-green-600 h-2 rounded-full transition-all duration-300"
                  style={{ width: `${Math.min(targetProgress, 100)}%` }}
                />
              </div>
              <span className="text-sm font-medium">
                {targetProgress.toFixed(0)}%
              </span>
            </div>
          </div>
        </div>

        {/* Chart */}
        {data.chartData && data.chartData.length > 0 && (
          <div className="h-32">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={data.chartData}>
                <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
                <XAxis 
                  dataKey="month" 
                  axisLine={false}
                  tickLine={false}
                  tick={{ fontSize: 12 }}
                />
                <YAxis 
                  axisLine={false}
                  tickLine={false}
                  tick={{ fontSize: 12 }}
                  tickFormatter={(value) => `$${(value / 1000).toFixed(0)}k`}
                />
                <Tooltip
                  formatter={(value: number) => [formatCurrency(value), 'Revenue']}
                  labelFormatter={(label) => `Month: ${label}`}
                  contentStyle={{
                    backgroundColor: 'white',
                    border: '1px solid #e5e7eb',
                    borderRadius: '8px',
                    boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
                  }}
                />
                <Line
                  type="monotone"
                  dataKey="revenue"
                  stroke="#10b981"
                  strokeWidth={2}
                  dot={{ fill: '#10b981', strokeWidth: 2, r: 4 }}
                  activeDot={{ r: 6, stroke: '#10b981', strokeWidth: 2 }}
                />
                <Line
                  type="monotone"
                  dataKey="target"
                  stroke="#6b7280"
                  strokeWidth={2}
                  strokeDasharray="5 5"
                  dot={{ fill: '#6b7280', strokeWidth: 2, r: 4 }}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        )}

        {/* Quick Actions */}
        <div className="flex items-center justify-between pt-2">
          <div className="flex items-center space-x-2">
            <Badge variant="outline" className="text-xs">
              {targetProgress >= 100 ? 'Target Met' : 'In Progress'}
            </Badge>
          </div>
          <Button variant="ghost" size="sm">
            <MoreHorizontal className="h-4 w-4" />
          </Button>
        </div>
      </CardContent>
    </DashboardWidget>
  );
});

RevenueWidget.displayName = 'RevenueWidget';

export default RevenueWidget;


===== FILE: client/src/features/documents/analytics/AnalyticsDashboard.ts =====
import { BaseDocument } from '../types/document.types';
import { AnalyticsData, DashboardWidget, AnalyticsMetric } from '../types/analytics.types';

/**
 * Analytics Dashboard - Comprehensive document analytics and usage tracking
 * 
 * This system provides:
 * - Real-time analytics and metrics
 * - Interactive dashboard widgets
 * - Usage tracking and insights
 * - Performance monitoring
 * - Custom reporting and exports
 */
export class AnalyticsDashboard {
  private dataCollector: AnalyticsDataCollector;
  private metricCalculator: MetricCalculator;
  private widgetRenderer: WidgetRenderer;
  private reportGenerator: ReportGenerator;
  private alertManager: AlertManager;

  constructor() {
    this.dataCollector = new AnalyticsDataCollector();
    this.metricCalculator = new MetricCalculator();
    this.widgetRenderer = new WidgetRenderer();
    this.reportGenerator = new ReportGenerator();
    this.alertManager = new AlertManager();
  }

  /**
   * Get dashboard data
   */
  async getDashboardData(
    options: DashboardOptions = {}
  ): Promise<DashboardData> {
    try {
      const startTime = Date.now();

      // Collect analytics data
      const analyticsData = await this.dataCollector.collectData(options);

      // Calculate metrics
      const metrics = await this.metricCalculator.calculateMetrics(analyticsData);

      // Generate widgets
      const widgets = await this.generateWidgets(metrics, options);

      // Check for alerts
      const alerts = await this.alertManager.checkAlerts(metrics);

      return {
        metrics,
        widgets,
        alerts,
        lastUpdated: new Date(),
        processingTime: Date.now() - startTime,
        metadata: {
          dataRange: options.timeRange,
          filters: options.filters,
          userId: options.userId
        }
      };

    } catch (error) {
      throw new Error(`Failed to get dashboard data: ${error.message}`);
    }
  }

  /**
   * Get specific analytics metric
   */
  async getMetric(
    metricName: string,
    options: MetricOptions = {}
  ): Promise<MetricResult> {
    try {
      // Collect data for specific metric
      const data = await this.dataCollector.collectMetricData(metricName, options);

      // Calculate metric
      const metric = await this.metricCalculator.calculateMetric(metricName, data);

      return {
        metric: metricName,
        value: metric.value,
        trend: metric.trend,
        change: metric.change,
        metadata: metric.metadata,
        timestamp: new Date()
      };

    } catch (error) {
      throw new Error(`Failed to get metric ${metricName}: ${error.message}`);
    }
  }

  /**
   * Get usage analytics
   */
  async getUsageAnalytics(
    options: UsageAnalyticsOptions = {}
  ): Promise<UsageAnalytics> {
    try {
      const startTime = Date.now();

      // Collect usage data
      const usageData = await this.dataCollector.collectUsageData(options);

      // Calculate usage metrics
      const metrics = await this.calculateUsageMetrics(usageData);

      // Generate insights
      const insights = await this.generateUsageInsights(metrics);

      return {
        totalDocuments: metrics.totalDocuments,
        activeUsers: metrics.activeUsers,
        documentTypes: metrics.documentTypes,
        usagePatterns: metrics.usagePatterns,
        collaborationMetrics: metrics.collaborationMetrics,
        performanceMetrics: metrics.performanceMetrics,
        insights,
        processingTime: Date.now() - startTime,
        metadata: {
          timeRange: options.timeRange,
          granularity: options.granularity
        }
      };

    } catch (error) {
      throw new Error(`Failed to get usage analytics: ${error.message}`);
    }
  }

  /**
   * Get performance analytics
   */
  async getPerformanceAnalytics(
    options: PerformanceAnalyticsOptions = {}
  ): Promise<PerformanceAnalytics> {
    try {
      const startTime = Date.now();

      // Collect performance data
      const performanceData = await this.dataCollector.collectPerformanceData(options);

      // Calculate performance metrics
      const metrics = await this.calculatePerformanceMetrics(performanceData);

      // Generate performance insights
      const insights = await this.generatePerformanceInsights(metrics);

      return {
        loadTime: metrics.loadTime,
        renderTime: metrics.renderTime,
        memoryUsage: metrics.memoryUsage,
        cachePerformance: metrics.cachePerformance,
        apiPerformance: metrics.apiPerformance,
        userExperience: metrics.userExperience,
        insights,
        processingTime: Date.now() - startTime,
        metadata: {
          timeRange: options.timeRange,
          includeDetails: options.includeDetails
        }
      };

    } catch (error) {
      throw new Error(`Failed to get performance analytics: ${error.message}`);
    }
  }

  /**
   * Generate custom report
   */
  async generateReport(
    reportConfig: ReportConfiguration,
    options: ReportOptions = {}
  ): Promise<ReportResult> {
    try {
      const startTime = Date.now();

      // Collect data for report
      const reportData = await this.dataCollector.collectReportData(reportConfig);

      // Generate report
      const report = await this.reportGenerator.generateReport(reportConfig, reportData);

      // Export report if requested
      let exportResult;
      if (options.export) {
        exportResult = await this.exportReport(report, options.export);
      }

      return {
        report,
        export: exportResult,
        processingTime: Date.now() - startTime,
        metadata: {
          reportId: report.id,
          generatedAt: new Date(),
          generatedBy: options.generatedBy
        }
      };

    } catch (error) {
      throw new Error(`Failed to generate report: ${error.message}`);
    }
  }

  /**
   * Create custom widget
   */
  async createWidget(
    widgetConfig: WidgetConfiguration,
    options: WidgetOptions = {}
  ): Promise<WidgetResult> {
    try {
      // Validate widget configuration
      const validation = await this.validateWidgetConfig(widgetConfig);
      if (!validation.valid) {
        return {
          success: false,
          errors: validation.errors
        };
      }

      // Create widget
      const widget = await this.widgetRenderer.createWidget(widgetConfig, options);

      // Store widget configuration
      await this.storeWidgetConfiguration(widget.id, widgetConfig);

      return {
        success: true,
        widget,
        widgetId: widget.id
      };

    } catch (error) {
      throw new Error(`Failed to create widget: ${error.message}`);
    }
  }

  /**
   * Get widget data
   */
  async getWidgetData(
    widgetId: string,
    options: WidgetDataOptions = {}
  ): Promise<WidgetData> {
    try {
      // Get widget configuration
      const widgetConfig = await this.getWidgetConfiguration(widgetId);

      // Collect data for widget
      const data = await this.dataCollector.collectWidgetData(widgetConfig, options);

      // Render widget data
      const widgetData = await this.widgetRenderer.renderWidgetData(widgetConfig, data);

      return {
        widgetId,
        data: widgetData,
        lastUpdated: new Date(),
        metadata: {
          config: widgetConfig,
          options
        }
      };

    } catch (error) {
      throw new Error(`Failed to get widget data: ${error.message}`);
    }
  }

  /**
   * Set up alerts
   */
  async setupAlert(
    alertConfig: AlertConfiguration,
    options: AlertOptions = {}
  ): Promise<AlertResult> {
    try {
      // Validate alert configuration
      const validation = await this.validateAlertConfig(alertConfig);
      if (!validation.valid) {
        return {
          success: false,
          errors: validation.errors
        };
      }

      // Create alert
      const alert = await this.alertManager.createAlert(alertConfig, options);

      return {
        success: true,
        alert,
        alertId: alert.id
      };

    } catch (error) {
      throw new Error(`Failed to setup alert: ${error.message}`);
    }
  }

  /**
   * Get analytics insights
   */
  async getAnalyticsInsights(
    options: InsightsOptions = {}
  ): Promise<AnalyticsInsights> {
    try {
      const startTime = Date.now();

      // Collect comprehensive data
      const data = await this.dataCollector.collectComprehensiveData(options);

      // Analyze data for insights
      const insights = await this.analyzeDataForInsights(data);

      // Generate recommendations
      const recommendations = await this.generateRecommendations(insights);

      return {
        insights,
        recommendations,
        confidence: insights.confidence,
        processingTime: Date.now() - startTime,
        metadata: {
          analysisDate: new Date(),
          dataSource: options.dataSource,
          includePredictions: options.includePredictions
        }
      };

    } catch (error) {
      throw new Error(`Failed to get analytics insights: ${error.message}`);
    }
  }

  // Private helper methods
  private async generateWidgets(
    metrics: AnalyticsMetric[],
    options: DashboardOptions
  ): Promise<DashboardWidget[]> {
    const widgets: DashboardWidget[] = [];

    // Generate default widgets based on metrics
    for (const metric of metrics) {
      const widget = await this.createMetricWidget(metric, options);
      widgets.push(widget);
    }

    // Generate custom widgets if specified
    if (options.customWidgets) {
      for (const widgetConfig of options.customWidgets) {
        const widget = await this.createCustomWidget(widgetConfig);
        widgets.push(widget);
      }
    }

    return widgets;
  }

  private async calculateUsageMetrics(usageData: any): Promise<UsageMetrics> {
    // Calculate usage metrics from data
    return {
      totalDocuments: 0,
      activeUsers: 0,
      documentTypes: {},
      usagePatterns: {},
      collaborationMetrics: {},
      performanceMetrics: {}
    };
  }

  private async generateUsageInsights(metrics: UsageMetrics): Promise<UsageInsight[]> {
    // Generate usage insights
    return [];
  }

  private async calculatePerformanceMetrics(performanceData: any): Promise<PerformanceMetrics> {
    // Calculate performance metrics
    return {
      loadTime: 0,
      renderTime: 0,
      memoryUsage: 0,
      cachePerformance: {},
      apiPerformance: {},
      userExperience: {}
    };
  }

  private async generatePerformanceInsights(metrics: PerformanceMetrics): Promise<PerformanceInsight[]> {
    // Generate performance insights
    return [];
  }

  private async exportReport(report: any, exportOptions: ExportOptions): Promise<ExportResult> {
    // Export report in specified format
    return {
      format: exportOptions.format,
      url: '',
      size: 0
    };
  }

  private async validateWidgetConfig(config: WidgetConfiguration): Promise<ValidationResult> {
    // Validate widget configuration
    return { valid: true, errors: [] };
  }

  private async storeWidgetConfiguration(widgetId: string, config: WidgetConfiguration): Promise<void> {
    // Store widget configuration
  }

  private async getWidgetConfiguration(widgetId: string): Promise<WidgetConfiguration> {
    // Get widget configuration
    return {} as WidgetConfiguration;
  }

  private async validateAlertConfig(config: AlertConfiguration): Promise<ValidationResult> {
    // Validate alert configuration
    return { valid: true, errors: [] };
  }

  private async analyzeDataForInsights(data: any): Promise<DataInsights> {
    // Analyze data for insights
    return {
      trends: [],
      patterns: [],
      anomalies: [],
      confidence: 0.8
    };
  }

  private async generateRecommendations(insights: DataInsights): Promise<Recommendation[]> {
    // Generate recommendations based on insights
    return [];
  }

  private async createMetricWidget(metric: AnalyticsMetric, options: DashboardOptions): Promise<DashboardWidget> {
    // Create widget for metric
    return {
      id: `widget_${metric.name}`,
      type: 'metric',
      title: metric.name,
      data: metric,
      config: {}
    };
  }

  private async createCustomWidget(config: WidgetConfiguration): Promise<DashboardWidget> {
    // Create custom widget
    return {
      id: config.id,
      type: config.type,
      title: config.title,
      data: {},
      config: config.config
    };
  }
}

// Supporting classes
export class AnalyticsDataCollector {
  async collectData(options: DashboardOptions): Promise<AnalyticsData> {
    // Collect analytics data
    return {
      documents: [],
      users: [],
      activities: [],
      performance: {}
    };
  }

  async collectMetricData(metricName: string, options: MetricOptions): Promise<any> {
    // Collect data for specific metric
    return {};
  }

  async collectUsageData(options: UsageAnalyticsOptions): Promise<any> {
    // Collect usage data
    return {};
  }

  async collectPerformanceData(options: PerformanceAnalyticsOptions): Promise<any> {
    // Collect performance data
    return {};
  }

  async collectReportData(config: ReportConfiguration): Promise<any> {
    // Collect data for report
    return {};
  }

  async collectWidgetData(config: WidgetConfiguration, options: WidgetDataOptions): Promise<any> {
    // Collect data for widget
    return {};
  }

  async collectComprehensiveData(options: InsightsOptions): Promise<any> {
    // Collect comprehensive data
    return {};
  }
}

export class MetricCalculator {
  async calculateMetrics(data: AnalyticsData): Promise<AnalyticsMetric[]> {
    // Calculate analytics metrics
    return [];
  }

  async calculateMetric(metricName: string, data: any): Promise<MetricValue> {
    // Calculate specific metric
    return {
      value: 0,
      trend: 'stable',
      change: 0,
      metadata: {}
    };
  }
}

export class WidgetRenderer {
  async createWidget(config: WidgetConfiguration, options: WidgetOptions): Promise<DashboardWidget> {
    // Create widget
    return {
      id: config.id,
      type: config.type,
      title: config.title,
      data: {},
      config: config.config
    };
  }

  async renderWidgetData(config: WidgetConfiguration, data: any): Promise<any> {
    // Render widget data
    return data;
  }
}

export class ReportGenerator {
  async generateReport(config: ReportConfiguration, data: any): Promise<Report> {
    // Generate report
    return {
      id: 'report_id',
      title: config.title,
      content: {},
      format: config.format,
      generatedAt: new Date()
    };
  }
}

export class AlertManager {
  async checkAlerts(metrics: AnalyticsMetric[]): Promise<Alert[]> {
    // Check for alerts
    return [];
  }

  async createAlert(config: AlertConfiguration, options: AlertOptions): Promise<Alert> {
    // Create alert
    return {
      id: 'alert_id',
      type: config.type,
      message: config.message,
      severity: config.severity,
      triggeredAt: new Date()
    };
  }
}

// Supporting interfaces
export interface DashboardOptions {
  timeRange?: DateRange;
  filters?: Record<string, any>;
  userId?: string;
  customWidgets?: WidgetConfiguration[];
}

export interface DateRange {
  start: Date;
  end: Date;
}

export interface DashboardData {
  metrics: AnalyticsMetric[];
  widgets: DashboardWidget[];
  alerts: Alert[];
  lastUpdated: Date;
  processingTime: number;
  metadata: any;
}

export interface MetricOptions {
  timeRange?: DateRange;
  granularity?: 'hour' | 'day' | 'week' | 'month';
  filters?: Record<string, any>;
}

export interface MetricResult {
  metric: string;
  value: number;
  trend: 'increasing' | 'decreasing' | 'stable';
  change: number;
  metadata: any;
  timestamp: Date;
}

export interface UsageAnalyticsOptions {
  timeRange?: DateRange;
  granularity?: 'hour' | 'day' | 'week' | 'month';
  includeDetails?: boolean;
}

export interface UsageAnalytics {
  totalDocuments: number;
  activeUsers: number;
  documentTypes: Record<string, number>;
  usagePatterns: UsagePattern[];
  collaborationMetrics: CollaborationMetrics;
  performanceMetrics: PerformanceMetrics;
  insights: UsageInsight[];
  processingTime: number;
  metadata: any;
}

export interface UsagePattern {
  time: Date;
  value: number;
  type: string;
}

export interface CollaborationMetrics {
  activeCollaborators: number;
  commentsPerDocument: number;
  suggestionsPerDocument: number;
  averageSessionTime: number;
}

export interface PerformanceMetrics {
  loadTime: number;
  renderTime: number;
  memoryUsage: number;
  cachePerformance: any;
  apiPerformance: any;
  userExperience: any;
}

export interface UsageInsight {
  type: string;
  description: string;
  confidence: number;
  impact: 'low' | 'medium' | 'high';
}

export interface PerformanceInsight {
  type: string;
  description: string;
  recommendation: string;
  priority: 'low' | 'medium' | 'high';
}

export interface PerformanceAnalyticsOptions {
  timeRange?: DateRange;
  includeDetails?: boolean;
}

export interface PerformanceAnalytics {
  loadTime: number;
  renderTime: number;
  memoryUsage: number;
  cachePerformance: any;
  apiPerformance: any;
  userExperience: any;
  insights: PerformanceInsight[];
  processingTime: number;
  metadata: any;
}

export interface ReportConfiguration {
  title: string;
  type: 'usage' | 'performance' | 'custom';
  format: 'pdf' | 'excel' | 'csv' | 'json';
  metrics: string[];
  timeRange: DateRange;
  filters?: Record<string, any>;
}

export interface ReportOptions {
  export?: ExportOptions;
  generatedBy?: string;
}

export interface ExportOptions {
  format: 'pdf' | 'excel' | 'csv' | 'json';
  filename?: string;
}

export interface ReportResult {
  report: Report;
  export?: ExportResult;
  processingTime: number;
  metadata: any;
}

export interface Report {
  id: string;
  title: string;
  content: any;
  format: string;
  generatedAt: Date;
}

export interface ExportResult {
  format: string;
  url: string;
  size: number;
}

export interface WidgetConfiguration {
  id: string;
  type: 'metric' | 'chart' | 'table' | 'custom';
  title: string;
  config: any;
}

export interface WidgetOptions {
  refreshInterval?: number;
  autoRefresh?: boolean;
}

export interface WidgetResult {
  success: boolean;
  widget?: DashboardWidget;
  widgetId?: string;
  errors?: string[];
}

export interface DashboardWidget {
  id: string;
  type: string;
  title: string;
  data: any;
  config: any;
}

export interface WidgetDataOptions {
  refresh?: boolean;
  includeMetadata?: boolean;
}

export interface WidgetData {
  widgetId: string;
  data: any;
  lastUpdated: Date;
  metadata: any;
}

export interface AlertConfiguration {
  id: string;
  type: 'threshold' | 'anomaly' | 'trend';
  metric: string;
  condition: string;
  threshold?: number;
  message: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
}

export interface AlertOptions {
  enabled?: boolean;
  notificationChannels?: string[];
}

export interface AlertResult {
  success: boolean;
  alert?: Alert;
  alertId?: string;
  errors?: string[];
}

export interface Alert {
  id: string;
  type: string;
  message: string;
  severity: string;
  triggeredAt: Date;
}

export interface InsightsOptions {
  timeRange?: DateRange;
  dataSource?: string;
  includePredictions?: boolean;
}

export interface AnalyticsInsights {
  insights: DataInsights;
  recommendations: Recommendation[];
  confidence: number;
  processingTime: number;
  metadata: any;
}

export interface DataInsights {
  trends: Trend[];
  patterns: Pattern[];
  anomalies: Anomaly[];
  confidence: number;
}

export interface Trend {
  metric: string;
  direction: 'up' | 'down' | 'stable';
  strength: number;
  timeframe: string;
}

export interface Pattern {
  type: string;
  description: string;
  frequency: number;
  confidence: number;
}

export interface Anomaly {
  type: string;
  description: string;
  severity: 'low' | 'medium' | 'high';
  timestamp: Date;
}

export interface Recommendation {
  type: string;
  title: string;
  description: string;
  priority: 'low' | 'medium' | 'high';
  actionable: boolean;
}

export interface ValidationResult {
  valid: boolean;
  errors: string[];
}

export interface UsageMetrics {
  totalDocuments: number;
  activeUsers: number;
  documentTypes: Record<string, number>;
  usagePatterns: Record<string, any>;
  collaborationMetrics: CollaborationMetrics;
  performanceMetrics: PerformanceMetrics;
}


===== FILE: client/src/features/documents/types/analytics.types.ts =====
export interface UsagePattern {
  id: string;
  userId: string;
  documentId: string;
  action: string;
  timestamp: Date;
  duration?: number;
  metadata?: Record<string, any>;
}

export interface CollaborationMetrics {
  activeCollaborators: number;
  commentsPerDocument: number;
  suggestionsPerDocument: number;
  averageSessionTime: number;
  realTimeEdits: number;
  mentionsPerDocument: number;
}

export interface PerformanceMetrics {
  loadTime: number;
  renderTime: number;
  memoryUsage: number;
  cachePerformance: number;
  apiResponseTime: number;
  errorRate: number;
}

export interface MetricValue {
  value: number;
  unit: string;
  trend: 'up' | 'down' | 'stable';
  change: number;
}

export interface DocumentAnalytics {
  documentId: string;
  views: number;
  edits: number;
  comments: number;
  shares: number;
  lastAccessed: Date;
  averageSessionTime: number;
  userEngagement: number;
}

export interface UserAnalytics {
  userId: string;
  documentsCreated: number;
  documentsEdited: number;
  commentsMade: number;
  timeSpent: number;
  lastActive: Date;
  preferredFeatures: string[];
}

export interface AnalyticsDashboard {
  usagePatterns: UsagePattern[];
  collaborationMetrics: CollaborationMetrics;
  performanceMetrics: PerformanceMetrics;
  documentAnalytics: DocumentAnalytics[];
  userAnalytics: UserAnalytics[];
  totalUsers: number;
  totalDocuments: number;
  averageSessionTime: number;
  topFeatures: string[];
}


===== FILE: client/src/components/dashboard/types/dashboard.types.ts =====
import { UserType } from "@shared/schema";

// Widget Definition
export interface DashboardWidget {
  id: string;
  type: string;
  title: string;
  component: React.ComponentType<WidgetProps>;
  size: 'small' | 'medium' | 'large' | 'full';
  minSize?: { w: number; h: number };
  maxSize?: { w: number; h: number };
  permissions: string[];
  userTypes: UserType[];
  category: 'analytics' | 'activity' | 'ai' | 'goals' | 'funding' | 'credit' | 'general';
  refreshInterval?: number;
  priority: number;
  defaultEnabled: boolean;
  description?: string;
  icon?: React.ComponentType<any>;
}

// Widget Props
export interface WidgetProps {
  widgetId: string;
  config?: WidgetConfig;
  data?: any;
  loading?: boolean;
  error?: Error | null;
  onConfigChange?: (config: WidgetConfig) => void;
  onRefresh?: () => void;
}

// Widget Configuration
export interface WidgetConfig {
  enabled: boolean;
  refreshInterval?: number;
  autoRefresh?: boolean;
  customSettings?: Record<string, any>;
  position?: { x: number; y: number };
  size?: { w: number; h: number };
  visible?: boolean;
  locked?: boolean;
}

// Dashboard Configuration
export interface DashboardConfig {
  userType: UserType;
  layout: WidgetLayout[];
  widgets: DashboardWidget[];
  theme: DashboardTheme;
  preferences: UserPreferences;
}

// Widget Layout
export interface WidgetLayout {
  widgetId: string;
  position: { x: number; y: number };
  size: { w: number; h: number };
  visible: boolean;
  locked: boolean;
}

// Dashboard Theme
export interface DashboardTheme {
  mode: 'light' | 'dark' | 'system';
  primaryColor: string;
  accentColor: string;
  density: 'compact' | 'normal' | 'comfortable';
}

// User Preferences
export interface UserPreferences {
  sidebarCollapsed: boolean;
  showWidgetTitles: boolean;
  enableAnimations: boolean;
  gridDensity: 'compact' | 'normal' | 'comfortable';
  defaultTimeRange: string;
  notifications: NotificationPreferences;
}

// Notification Preferences
export interface NotificationPreferences {
  email: boolean;
  push: boolean;
  inApp: boolean;
  frequency: 'instant' | 'hourly' | 'daily';
}

// Dashboard State
export interface DashboardState {
  // Layout state
  layout: WidgetLayout[];
  activeWidgets: string[];
  collapsedWidgets: string[];
  
  // Data state
  widgetData: Record<string, any>;
  loadingStates: Record<string, boolean>;
  errors: Record<string, Error | null>;
  
  // UI state
  sidebarOpen: boolean;
  selectedWidget: string | null;
  editMode: boolean;
  
  // User preferences
  preferences: UserPreferences;
  customizations: DashboardCustomizations;
}

// Dashboard Customizations
export interface DashboardCustomizations {
  customWidgets: DashboardWidget[];
  savedLayouts: SavedLayout[];
  widgetOrder: string[];
}

// Saved Layout
export interface SavedLayout {
  id: string;
  name: string;
  description?: string;
  layout: WidgetLayout[];
  isDefault?: boolean;
  createdAt: Date;
}

// Dashboard Actions
export type DashboardAction =
  | { type: 'ADD_WIDGET'; payload: DashboardWidget }
  | { type: 'REMOVE_WIDGET'; payload: string }
  | { type: 'UPDATE_LAYOUT'; payload: WidgetLayout[] }
  | { type: 'TOGGLE_WIDGET'; payload: string }
  | { type: 'SET_WIDGET_DATA'; payload: { id: string; data: any } }
  | { type: 'SET_LOADING'; payload: { id: string; loading: boolean } }
  | { type: 'SET_ERROR'; payload: { id: string; error: Error | null } }
  | { type: 'UPDATE_PREFERENCES'; payload: Partial<UserPreferences> }
  | { type: 'TOGGLE_SIDEBAR' }
  | { type: 'SET_EDIT_MODE'; payload: boolean }
  | { type: 'SAVE_LAYOUT'; payload: SavedLayout }
  | { type: 'LOAD_LAYOUT'; payload: string };

// Widget Registry
export interface WidgetRegistry {
  widgets: Map<string, DashboardWidget>;
  register: (widget: DashboardWidget) => void;
  unregister: (widgetId: string) => void;
  get: (widgetId: string) => DashboardWidget | undefined;
  getAll: () => DashboardWidget[];
  getByCategory: (category: string) => DashboardWidget[];
  getByUserType: (userType: UserType) => DashboardWidget[];
}

// Design Tokens
export interface DesignTokens {
  spacing: {
    widget: {
      padding: string;
      gap: string;
      margin: string;
    };
    grid: {
      columns: number;
      gutter: string;
      rowHeight: string;
    };
  };
  typography: {
    header: {
      fontSize: string;
      fontWeight: number;
      lineHeight: number;
    };
    widgetTitle: {
      fontSize: string;
      fontWeight: number;
      lineHeight: number;
    };
    metric: {
      fontSize: string;
      fontWeight: number;
      lineHeight: number;
    };
  };
  colors: {
    widget: {
      background: string;
      border: string;
      hover: string;
    };
    metrics: {
      positive: string;
      negative: string;
      neutral: string;
    };
    status: {
      success: string;
      warning: string;
      error: string;
      info: string;
    };
  };
  shadows: {
    widget: string;
    widgetHover: string;
    widgetActive: string;
  };
  animations: {
    widgetEntry: string;
    widgetExit: string;
    dataUpdate: string;
  };
}

// Grid Configuration
export interface GridConfig {
  breakpoints: {
    xs: { cols: number; width: number };
    sm: { cols: number; width: number };
    md: { cols: number; width: number };
    lg: { cols: number; width: number };
    xl: { cols: number; width: number };
  };
  widgetSizes: {
    small: { w: number; h: number };
    medium: { w: number; h: number };
    large: { w: number; h: number };
    full: { w: number; h: number };
  };
}

// Widget Categories
export enum WidgetCategory {
  ANALYTICS = 'analytics',
  ACTIVITY = 'activity',
  AI = 'ai',
  GOALS = 'goals',
  FUNDING = 'funding',
  CREDIT = 'credit',
  GENERAL = 'general'
}

// Widget Variants
export type WidgetVariant = 'metric' | 'chart' | 'list' | 'action' | 'insight' | 'feed' | 'custom';


===== FILE: server/infographic-analytics-service.ts =====
import { InfographicData } from './ai-infographic-service';

export interface InfographicAnalytics {
  id: string;
  infographicId: string;
  userId: string;
  event: 'created' | 'viewed' | 'exported' | 'shared' | 'enhanced' | 'deleted';
  timestamp: Date;
  metadata: {
    format?: string;
    enhancementType?: string;
    shareMethod?: string;
    viewDuration?: number;
    userAgent?: string;
    ipAddress?: string;
  };
}

export interface InfographicUsageStats {
  totalInfographics: number;
  totalViews: number;
  totalExports: number;
  totalShares: number;
  averageViewsPerInfographic: number;
  mostPopularFormats: Array<{ format: string; count: number }>;
  mostUsedTemplates: Array<{ template: string; count: number }>;
  userEngagement: {
    averageViewDuration: number;
    bounceRate: number;
    returnRate: number;
  };
  timeBasedStats: {
    daily: Array<{ date: string; count: number }>;
    weekly: Array<{ week: string; count: number }>;
    monthly: Array<{ month: string; count: number }>;
  };
}

export interface UserInfographicStats {
  userId: string;
  totalCreated: number;
  totalViews: number;
  totalExports: number;
  totalShares: number;
  favoriteTemplates: string[];
  mostUsedFormats: string[];
  averageCreationTime: number;
  lastActivity: Date;
  engagementScore: number;
}

export class InfographicAnalyticsService {
  private analytics: InfographicAnalytics[] = [];
  private infographics: Map<string, InfographicData> = new Map();

  /**
   * Track an infographic event
   */
  async trackEvent(
    infographicId: string,
    userId: string,
    event: InfographicAnalytics['event'],
    metadata: Partial<InfographicAnalytics['metadata']> = {}
  ): Promise<void> {
    const analytics: InfographicAnalytics = {
      id: `analytics-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      infographicId,
      userId,
      event,
      timestamp: new Date(),
      metadata: {
        ...metadata,
        userAgent: metadata.userAgent || 'unknown',
        ipAddress: metadata.ipAddress || 'unknown'
      }
    };

    this.analytics.push(analytics);
    
    // Update infographic usage stats
    if (this.infographics.has(infographicId)) {
      const infographic = this.infographics.get(infographicId)!;
      infographic.metadata.usage[event === 'viewed' ? 'views' : 
                                 event === 'exported' ? 'exports' : 
                                 event === 'shared' ? 'shares' : 'views']++;
    }
  }

  /**
   * Register an infographic for tracking
   */
  async registerInfographic(infographic: InfographicData): Promise<void> {
    this.infographics.set(infographic.id, infographic);
    await this.trackEvent(infographic.id, infographic.metadata.userId, 'created');
  }

  /**
   * Get comprehensive usage statistics
   */
  async getUsageStats(timeRange?: { start: Date; end: Date }): Promise<InfographicUsageStats> {
    const filteredAnalytics = timeRange 
      ? this.analytics.filter(a => a.timestamp >= timeRange.start && a.timestamp <= timeRange.end)
      : this.analytics;

    const totalInfographics = this.infographics.size;
    const totalViews = filteredAnalytics.filter(a => a.event === 'viewed').length;
    const totalExports = filteredAnalytics.filter(a => a.event === 'exported').length;
    const totalShares = filteredAnalytics.filter(a => a.event === 'shared').length;

    // Calculate format popularity
    const formatCounts = new Map<string, number>();
    filteredAnalytics
      .filter(a => a.event === 'exported' && a.metadata.format)
      .forEach(a => {
        const format = a.metadata.format!;
        formatCounts.set(format, (formatCounts.get(format) || 0) + 1);
      });

    const mostPopularFormats = Array.from(formatCounts.entries())
      .map(([format, count]) => ({ format, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    // Calculate template usage
    const templateCounts = new Map<string, number>();
    this.infographics.forEach(infographic => {
      const template = infographic.metadata.category;
      templateCounts.set(template, (templateCounts.get(template) || 0) + 1);
    });

    const mostUsedTemplates = Array.from(templateCounts.entries())
      .map(([template, count]) => ({ template, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);

    // Calculate engagement metrics
    const viewEvents = filteredAnalytics.filter(a => a.event === 'viewed');
    const averageViewDuration = viewEvents.reduce((sum, event) => 
      sum + (event.metadata.viewDuration || 0), 0) / viewEvents.length || 0;

    // Calculate time-based stats
    const dailyStats = this.calculateTimeBasedStats(filteredAnalytics, 'daily');
    const weeklyStats = this.calculateTimeBasedStats(filteredAnalytics, 'weekly');
    const monthlyStats = this.calculateTimeBasedStats(filteredAnalytics, 'monthly');

    return {
      totalInfographics,
      totalViews,
      totalExports,
      totalShares,
      averageViewsPerInfographic: totalInfographics > 0 ? totalViews / totalInfographics : 0,
      mostPopularFormats,
      mostUsedTemplates,
      userEngagement: {
        averageViewDuration,
        bounceRate: 0.3, // Placeholder - would need more sophisticated tracking
        returnRate: 0.7   // Placeholder - would need more sophisticated tracking
      },
      timeBasedStats: {
        daily: dailyStats,
        weekly: weeklyStats,
        monthly: monthlyStats
      }
    };
  }

  /**
   * Get user-specific statistics
   */
  async getUserStats(userId: string): Promise<UserInfographicStats> {
    const userAnalytics = this.analytics.filter(a => a.userId === userId);
    const userInfographics = Array.from(this.infographics.values())
      .filter(i => i.metadata.userId === userId);

    const totalCreated = userInfographics.length;
    const totalViews = userAnalytics.filter(a => a.event === 'viewed').length;
    const totalExports = userAnalytics.filter(a => a.event === 'exported').length;
    const totalShares = userAnalytics.filter(a => a.event === 'shared').length;

    // Calculate favorite templates
    const templateCounts = new Map<string, number>();
    userInfographics.forEach(infographic => {
      const template = infographic.metadata.category;
      templateCounts.set(template, (templateCounts.get(template) || 0) + 1);
    });

    const favoriteTemplates = Array.from(templateCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([template]) => template);

    // Calculate most used formats
    const formatCounts = new Map<string, number>();
    userAnalytics
      .filter(a => a.event === 'exported' && a.metadata.format)
      .forEach(a => {
        const format = a.metadata.format!;
        formatCounts.set(format, (formatCounts.get(format) || 0) + 1);
      });

    const mostUsedFormats = Array.from(formatCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([format]) => format);

    // Calculate engagement score
    const engagementScore = this.calculateEngagementScore(userAnalytics, userInfographics);

    return {
      userId,
      totalCreated,
      totalViews,
      totalExports,
      totalShares,
      favoriteTemplates,
      mostUsedFormats,
      averageCreationTime: 0, // Placeholder - would need creation time tracking
      lastActivity: userAnalytics.length > 0 
        ? new Date(Math.max(...userAnalytics.map(a => a.timestamp.getTime())))
        : new Date(),
      engagementScore
    };
  }

  /**
   * Get trending infographics
   */
  async getTrendingInfographics(limit: number = 10): Promise<Array<{
    infographic: InfographicData;
    views: number;
    exports: number;
    shares: number;
    engagementScore: number;
  }>> {
    const infographicStats = new Map<string, {
      infographic: InfographicData;
      views: number;
      exports: number;
      shares: number;
    }>();

    // Aggregate stats for each infographic
    this.analytics.forEach(analytics => {
      if (!infographicStats.has(analytics.infographicId)) {
        const infographic = this.infographics.get(analytics.infographicId);
        if (infographic) {
          infographicStats.set(analytics.infographicId, {
            infographic,
            views: 0,
            exports: 0,
            shares: 0
          });
        }
      }

      const stats = infographicStats.get(analytics.infographicId);
      if (stats) {
        switch (analytics.event) {
          case 'viewed':
            stats.views++;
            break;
          case 'exported':
            stats.exports++;
            break;
          case 'shared':
            stats.shares++;
            break;
        }
      }
    });

    // Calculate engagement scores and sort
    return Array.from(infographicStats.values())
      .map(stats => ({
        ...stats,
        engagementScore: this.calculateInfographicEngagementScore(stats)
      }))
      .sort((a, b) => b.engagementScore - a.engagementScore)
      .slice(0, limit);
  }

  /**
   * Get performance insights
   */
  async getPerformanceInsights(): Promise<{
    topPerformingTemplates: Array<{ template: string; performance: number }>;
    optimalExportFormats: Array<{ format: string; usage: number }>;
    userBehaviorPatterns: Array<{ pattern: string; frequency: number }>;
    recommendations: string[];
  }> {
    const stats = await this.getUsageStats();
    
    // Analyze template performance
    const templatePerformance = stats.mostUsedTemplates.map(template => ({
      template: template.template,
      performance: template.count / stats.totalInfographics
    }));

    // Analyze export format usage
    const formatUsage = stats.mostPopularFormats.map(format => ({
      format: format.format,
      usage: format.count / stats.totalExports
    }));

    // Identify user behavior patterns
    const behaviorPatterns = this.analyzeUserBehaviorPatterns();

    // Generate recommendations
    const recommendations = this.generateRecommendations(stats);

    return {
      topPerformingTemplates: templatePerformance,
      optimalExportFormats: formatUsage,
      userBehaviorPatterns: behaviorPatterns,
      recommendations
    };
  }

  private calculateTimeBasedStats(
    analytics: InfographicAnalytics[], 
    granularity: 'daily' | 'weekly' | 'monthly'
  ): Array<{ date: string; count: number }> {
    const stats = new Map<string, number>();

    analytics.forEach(analytics => {
      let key: string;
      const date = new Date(analytics.timestamp);

      switch (granularity) {
        case 'daily':
          key = date.toISOString().split('T')[0];
          break;
        case 'weekly':
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay());
          key = weekStart.toISOString().split('T')[0];
          break;
        case 'monthly':
          key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          break;
      }

      stats.set(key, (stats.get(key) || 0) + 1);
    });

    return Array.from(stats.entries())
      .map(([date, count]) => ({ date, count }))
      .sort((a, b) => a.date.localeCompare(b.date));
  }

  private calculateEngagementScore(
    userAnalytics: InfographicAnalytics[],
    userInfographics: InfographicData[]
  ): number {
    const views = userAnalytics.filter(a => a.event === 'viewed').length;
    const exports = userAnalytics.filter(a => a.event === 'exported').length;
    const shares = userAnalytics.filter(a => a.event === 'shared').length;
    const enhancements = userAnalytics.filter(a => a.event === 'enhanced').length;

    // Weighted scoring
    const score = (views * 1) + (exports * 3) + (shares * 5) + (enhancements * 2);
    const maxPossibleScore = userInfographics.length * 10; // Assuming max 10 actions per infographic

    return maxPossibleScore > 0 ? Math.min(score / maxPossibleScore, 1) : 0;
  }

  private calculateInfographicEngagementScore(stats: {
    views: number;
    exports: number;
    shares: number;
  }): number {
    return (stats.views * 1) + (stats.exports * 3) + (stats.shares * 5);
  }

  private analyzeUserBehaviorPatterns(): Array<{ pattern: string; frequency: number }> {
    // This would analyze user behavior patterns
    // For now, return placeholder data
    return [
      { pattern: 'Users prefer PNG exports', frequency: 0.65 },
      { pattern: 'Revenue charts are most popular', frequency: 0.45 },
      { pattern: 'Users enhance infographics 2-3 times', frequency: 0.32 },
      { pattern: 'Corporate theme is preferred', frequency: 0.58 }
    ];
  }

  private generateRecommendations(stats: InfographicUsageStats): string[] {
    const recommendations: string[] = [];

    if (stats.averageViewsPerInfographic < 2) {
      recommendations.push('Consider adding more interactive features to increase engagement');
    }

    if (stats.mostPopularFormats[0]?.format === 'png') {
      recommendations.push('PNG is the most popular format - ensure high-quality rendering');
    }

    if (stats.userEngagement.averageViewDuration < 30) {
      recommendations.push('Infographics may need more compelling visual design');
    }

    return recommendations;
  }
}


===== FILE: server/services/dt-analytics-service.ts =====
import { DatabaseService } from './database-service';
import { DTAnalyticsEngine } from './dt-analytics-engine';
import { InsightTracker } from './insight-tracker';
import { ROICalculator } from './roi-calculator';
import { BenchmarkService } from './benchmark-service';

/**
 * Enhanced Design Thinking Analytics Service
 * 
 * This service provides comprehensive analytics for DT workflows:
 * - Effectiveness measurement
 * - ROI calculation
 * - Benchmark comparison
 * - Insight tracking
 * - Predictive analytics
 */
export class DTAnalyticsService {
  private db: DatabaseService;
  private analyticsEngine: DTAnalyticsEngine;
  private insightTracker: InsightTracker;
  private roiCalculator: ROICalculator;
  private benchmarkService: BenchmarkService;

  constructor() {
    this.db = new DatabaseService();
    this.analyticsEngine = new DTAnalyticsEngine();
    this.insightTracker = new InsightTracker();
    this.roiCalculator = new ROICalculator();
    this.benchmarkService = new BenchmarkService();
  }

  /**
   * Get comprehensive analytics for a DT workflow
   */
  async getComprehensiveAnalytics(workflowId: string): Promise<ComprehensiveAnalytics> {
    try {
      const workflow = await this.db.getWorkflow(workflowId);
      if (!workflow) {
        throw new Error('Workflow not found');
      }

      // Get all analytics components
      const [
        effectivenessScore,
        insightMap,
        roiAnalysis,
        benchmarkComparison,
        participantMetrics,
        phaseMetrics,
        collaborationMetrics,
        outcomeMetrics
      ] = await Promise.all([
        this.analyticsEngine.calculateEffectivenessScore(workflowId),
        this.analyticsEngine.generateInsightMap(workflowId),
        this.roiCalculator.calculateROI(workflow),
        this.benchmarkService.compareToBenchmarks(workflow),
        this.getParticipantMetrics(workflowId),
        this.getPhaseMetrics(workflowId),
        this.getCollaborationMetrics(workflowId),
        this.getOutcomeMetrics(workflowId)
      ]);

      return {
        workflowId,
        effectivenessScore,
        insightMap,
        roiAnalysis,
        benchmarkComparison,
        participantMetrics,
        phaseMetrics,
        collaborationMetrics,
        outcomeMetrics,
        generatedAt: new Date()
      };
    } catch (error) {
      console.error('Error getting comprehensive analytics:', error);
      throw error;
    }
  }

  /**
   * Calculate effectiveness score for a workflow
   */
  async calculateEffectivenessScore(workflowId: string): Promise<EffectivenessScore> {
    return await this.analyticsEngine.calculateEffectivenessScore(workflowId);
  }

  /**
   * Generate insight map for a workflow
   */
  async generateInsightMap(workflowId: string): Promise<InsightMap> {
    return await this.analyticsEngine.generateInsightMap(workflowId);
  }

  /**
   * Track insight evolution
   */
  async trackInsightEvolution(insightId: string): Promise<InsightEvolution> {
    return await this.insightTracker.trackEvolution(insightId);
  }

  /**
   * Calculate ROI for a workflow
   */
  async calculateROI(workflowId: string): Promise<ROIAnalysis> {
    const workflow = await this.db.getWorkflow(workflowId);
    if (!workflow) {
      throw new Error('Workflow not found');
    }

    return await this.roiCalculator.calculateROI(workflow);
  }

  /**
   * Compare workflow to benchmarks
   */
  async compareToBenchmarks(workflowId: string): Promise<BenchmarkComparison> {
    const workflow = await this.db.getWorkflow(workflowId);
    if (!workflow) {
      throw new Error('Workflow not found');
    }

    return await this.benchmarkService.compareToBenchmarks(workflow);
  }

  /**
   * Get participant metrics
   */
  private async getParticipantMetrics(workflowId: string): Promise<ParticipantMetrics> {
    const participants = await this.db.getWorkflowParticipants(workflowId);
    const activities = await this.db.getWorkflowActivities(workflowId);

    const participationRates = participants.map(p => ({
      participantId: p.id,
      participationRate: this.calculateParticipationRate(p.id, activities),
      contributionQuality: this.calculateContributionQuality(p.id, activities),
      engagementScore: this.calculateEngagementScore(p.id, activities)
    }));

    return {
      totalParticipants: participants.length,
      averageParticipationRate: this.calculateAverage(participationRates.map(p => p.participationRate)),
      averageContributionQuality: this.calculateAverage(participationRates.map(p => p.contributionQuality)),
      averageEngagementScore: this.calculateAverage(participationRates.map(p => p.engagementScore)),
      participationDistribution: this.calculateParticipationDistribution(participationRates),
      topContributors: this.identifyTopContributors(participationRates),
      engagementTrends: await this.calculateEngagementTrends(workflowId)
    };
  }

  /**
   * Get phase metrics
   */
  private async getPhaseMetrics(workflowId: string): Promise<PhaseMetrics> {
    const phases = ['empathize', 'define', 'ideate', 'prototype', 'test'];
    const phaseMetrics: PhaseMetric[] = [];

    for (const phase of phases) {
      const phaseData = await this.db.getPhaseData(workflowId, phase);
      const metrics = await this.calculatePhaseMetrics(phase, phaseData);
      phaseMetrics.push(metrics);
    }

    return {
      phases: phaseMetrics,
      overallProgress: this.calculateOverallProgress(phaseMetrics),
      phaseTransitions: await this.calculatePhaseTransitions(workflowId),
      bottlenecks: this.identifyBottlenecks(phaseMetrics),
      recommendations: await this.generatePhaseRecommendations(phaseMetrics)
    };
  }

  /**
   * Get collaboration metrics
   */
  private async getCollaborationMetrics(workflowId: string): Promise<CollaborationMetrics> {
    const sessions = await this.db.getWorkflowSessions(workflowId);
    const collaborations = await this.db.getWorkflowCollaborations(workflowId);

    return {
      totalSessions: sessions.length,
      averageSessionDuration: this.calculateAverage(sessions.map(s => s.duration)),
      collaborationQuality: this.calculateCollaborationQuality(collaborations),
      conflictResolutionRate: this.calculateConflictResolutionRate(collaborations),
      realTimeUsage: this.calculateRealTimeUsage(sessions),
      mobileUsage: this.calculateMobileUsage(sessions),
      offlineUsage: this.calculateOfflineUsage(sessions),
      teamDynamics: await this.analyzeTeamDynamics(workflowId)
    };
  }

  /**
   * Get outcome metrics
   */
  private async getOutcomeMetrics(workflowId: string): Promise<OutcomeMetrics> {
    const outcomes = await this.db.getWorkflowOutcomes(workflowId);
    const prototypes = await this.db.getWorkflowPrototypes(workflowId);
    const tests = await this.db.getWorkflowTests(workflowId);

    return {
      totalOutcomes: outcomes.length,
      prototypeSuccessRate: this.calculatePrototypeSuccessRate(prototypes),
      testEffectiveness: this.calculateTestEffectiveness(tests),
      ideaToPrototypeRate: this.calculateIdeaToPrototypeRate(workflowId),
      prototypeToTestRate: this.calculatePrototypeToTestRate(workflowId),
      timeToInsight: this.calculateTimeToInsight(workflowId),
      businessImpact: await this.calculateBusinessImpact(workflowId),
      userSatisfaction: this.calculateUserSatisfaction(outcomes)
    };
  }

  /**
   * Generate predictive analytics
   */
  async generatePredictiveAnalytics(workflowId: string): Promise<PredictiveAnalytics> {
    const workflow = await this.db.getWorkflow(workflowId);
    const historicalData = await this.db.getHistoricalData(workflowId);
    const similarWorkflows = await this.db.getSimilarWorkflows(workflow);

    return {
      successProbability: await this.predictSuccessProbability(workflow, historicalData),
      estimatedCompletionTime: await this.predictCompletionTime(workflow, historicalData),
      resourceRequirements: await this.predictResourceRequirements(workflow, historicalData),
      riskFactors: await this.identifyRiskFactors(workflow, historicalData),
      opportunityAreas: await this.identifyOpportunityAreas(workflow, similarWorkflows),
      recommendations: await this.generatePredictiveRecommendations(workflow, historicalData)
    };
  }

  /**
   * Generate insights and recommendations
   */
  async generateInsightsAndRecommendations(workflowId: string): Promise<InsightsAndRecommendations> {
    const analytics = await this.getComprehensiveAnalytics(workflowId);
    const predictive = await this.generatePredictiveAnalytics(workflowId);

    return {
      keyInsights: await this.extractKeyInsights(analytics),
      improvementAreas: await this.identifyImprovementAreas(analytics),
      successFactors: await this.identifySuccessFactors(analytics),
      riskMitigation: await this.generateRiskMitigationStrategies(analytics),
      optimizationOpportunities: await this.identifyOptimizationOpportunities(analytics),
      nextSteps: await this.generateNextSteps(analytics, predictive),
      longTermStrategy: await this.generateLongTermStrategy(analytics, predictive)
    };
  }

  /**
   * Export analytics data
   */
  async exportAnalytics(workflowId: string, format: 'json' | 'csv' | 'pdf'): Promise<ExportData> {
    const analytics = await this.getComprehensiveAnalytics(workflowId);
    const predictive = await this.generatePredictiveAnalytics(workflowId);
    const insights = await this.generateInsightsAndRecommendations(workflowId);

    const exportData = {
      workflowId,
      analytics,
      predictive,
      insights,
      exportedAt: new Date()
    };

    switch (format) {
      case 'json':
        return {
          format: 'json',
          data: JSON.stringify(exportData, null, 2),
          filename: `dt-analytics-${workflowId}.json`
        };
      
      case 'csv':
        return {
          format: 'csv',
          data: await this.convertToCSV(exportData),
          filename: `dt-analytics-${workflowId}.csv`
        };
      
      case 'pdf':
        return {
          format: 'pdf',
          data: await this.generatePDF(exportData),
          filename: `dt-analytics-${workflowId}.pdf`
        };
      
      default:
        throw new Error('Unsupported export format');
    }
  }

  // Helper methods
  private calculateParticipationRate(participantId: string, activities: Activity[]): number {
    const participantActivities = activities.filter(a => a.participantId === participantId);
    const totalActivities = activities.length;
    return totalActivities > 0 ? participantActivities.length / totalActivities : 0;
  }

  private calculateContributionQuality(participantId: string, activities: Activity[]): number {
    const participantActivities = activities.filter(a => a.participantId === participantId);
    if (participantActivities.length === 0) return 0;

    const qualityScores = participantActivities.map(a => a.qualityScore || 0);
    return this.calculateAverage(qualityScores);
  }

  private calculateEngagementScore(participantId: string, activities: Activity[]): number {
    const participantActivities = activities.filter(a => a.participantId === participantId);
    if (participantActivities.length === 0) return 0;

    const engagementScores = participantActivities.map(a => a.engagementScore || 0);
    return this.calculateAverage(engagementScores);
  }

  private calculateAverage(numbers: number[]): number {
    if (numbers.length === 0) return 0;
    return numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
  }

  private calculateParticipationDistribution(participationRates: ParticipationRate[]): Distribution {
    const rates = participationRates.map(p => p.participationRate);
    return {
      low: rates.filter(r => r < 0.3).length,
      medium: rates.filter(r => r >= 0.3 && r < 0.7).length,
      high: rates.filter(r => r >= 0.7).length
    };
  }

  private identifyTopContributors(participationRates: ParticipationRate[]): TopContributor[] {
    return participationRates
      .sort((a, b) => b.contributionQuality - a.contributionQuality)
      .slice(0, 5)
      .map(p => ({
        participantId: p.participantId,
        contributionQuality: p.contributionQuality,
        participationRate: p.participationRate
      }));
  }

  private async calculateEngagementTrends(workflowId: string): Promise<EngagementTrend[]> {
    // Implementation for calculating engagement trends over time
    return [];
  }

  private async calculatePhaseMetrics(phase: string, phaseData: any): Promise<PhaseMetric> {
    // Implementation for calculating phase-specific metrics
    return {
      phase,
      duration: 0,
      activities: 0,
      participants: 0,
      quality: 0,
      progress: 0
    };
  }

  private calculateOverallProgress(phaseMetrics: PhaseMetric[]): number {
    const totalProgress = phaseMetrics.reduce((sum, phase) => sum + phase.progress, 0);
    return totalProgress / phaseMetrics.length;
  }

  private async calculatePhaseTransitions(workflowId: string): Promise<PhaseTransition[]> {
    // Implementation for calculating phase transitions
    return [];
  }

  private identifyBottlenecks(phaseMetrics: PhaseMetric[]): Bottleneck[] {
    return phaseMetrics
      .filter(phase => phase.duration > phaseMetrics.reduce((sum, p) => sum + p.duration, 0) / phaseMetrics.length * 1.5)
      .map(phase => ({
        phase: phase.phase,
        duration: phase.duration,
        severity: 'medium' as const
      }));
  }

  private async generatePhaseRecommendations(phaseMetrics: PhaseMetric[]): Promise<string[]> {
    // Implementation for generating phase recommendations
    return [];
  }

  private calculateCollaborationQuality(collaborations: Collaboration[]): number {
    if (collaborations.length === 0) return 0;
    const qualityScores = collaborations.map(c => c.qualityScore || 0);
    return this.calculateAverage(qualityScores);
  }

  private calculateConflictResolutionRate(collaborations: Collaboration[]): number {
    const totalConflicts = collaborations.reduce((sum, c) => sum + (c.conflicts?.length || 0), 0);
    const resolvedConflicts = collaborations.reduce((sum, c) => sum + (c.resolvedConflicts?.length || 0), 0);
    return totalConflicts > 0 ? resolvedConflicts / totalConflicts : 1;
  }

  private calculateRealTimeUsage(sessions: Session[]): number {
    const realTimeSessions = sessions.filter(s => s.realTime);
    return sessions.length > 0 ? realTimeSessions.length / sessions.length : 0;
  }

  private calculateMobileUsage(sessions: Session[]): number {
    const mobileSessions = sessions.filter(s => s.mobile);
    return sessions.length > 0 ? mobileSessions.length / sessions.length : 0;
  }

  private calculateOfflineUsage(sessions: Session[]): number {
    const offlineSessions = sessions.filter(s => s.offline);
    return sessions.length > 0 ? offlineSessions.length / sessions.length : 0;
  }

  private async analyzeTeamDynamics(workflowId: string): Promise<TeamDynamics> {
    // Implementation for analyzing team dynamics
    return {
      communicationQuality: 0,
      conflictResolution: 0,
      collaborationEffectiveness: 0,
      leadershipDistribution: 0
    };
  }

  private calculatePrototypeSuccessRate(prototypes: Prototype[]): number {
    if (prototypes.length === 0) return 0;
    const successfulPrototypes = prototypes.filter(p => p.success);
    return successfulPrototypes.length / prototypes.length;
  }

  private calculateTestEffectiveness(tests: Test[]): number {
    if (tests.length === 0) return 0;
    const effectiveTests = tests.filter(t => t.effective);
    return effectiveTests.length / tests.length;
  }

  private calculateIdeaToPrototypeRate(workflowId: string): number {
    // Implementation for calculating idea to prototype conversion rate
    return 0;
  }

  private calculatePrototypeToTestRate(workflowId: string): number {
    // Implementation for calculating prototype to test conversion rate
    return 0;
  }

  private calculateTimeToInsight(workflowId: string): number {
    // Implementation for calculating time to insight
    return 0;
  }

  private async calculateBusinessImpact(workflowId: string): Promise<BusinessImpact> {
    // Implementation for calculating business impact
    return {
      revenue: 0,
      costReduction: 0,
      customerSatisfaction: 0,
      competitiveAdvantage: 0,
      marketOpportunity: 0
    };
  }

  private calculateUserSatisfaction(outcomes: Outcome[]): number {
    if (outcomes.length === 0) return 0;
    const satisfactionScores = outcomes.map(o => o.satisfactionScore || 0);
    return this.calculateAverage(satisfactionScores);
  }

  private async predictSuccessProbability(workflow: Workflow, historicalData: any): Promise<number> {
    // Implementation for predicting success probability
    return 0.8;
  }

  private async predictCompletionTime(workflow: Workflow, historicalData: any): Promise<number> {
    // Implementation for predicting completion time
    return 0;
  }

  private async predictResourceRequirements(workflow: Workflow, historicalData: any): Promise<ResourceRequirements> {
    // Implementation for predicting resource requirements
    return {
      time: 0,
      people: 0,
      budget: 0
    };
  }

  private async identifyRiskFactors(workflow: Workflow, historicalData: any): Promise<RiskFactor[]> {
    // Implementation for identifying risk factors
    return [];
  }

  private async identifyOpportunityAreas(workflow: Workflow, similarWorkflows: Workflow[]): Promise<OpportunityArea[]> {
    // Implementation for identifying opportunity areas
    return [];
  }

  private async generatePredictiveRecommendations(workflow: Workflow, historicalData: any): Promise<string[]> {
    // Implementation for generating predictive recommendations
    return [];
  }

  private async extractKeyInsights(analytics: ComprehensiveAnalytics): Promise<KeyInsight[]> {
    // Implementation for extracting key insights
    return [];
  }

  private async identifyImprovementAreas(analytics: ComprehensiveAnalytics): Promise<ImprovementArea[]> {
    // Implementation for identifying improvement areas
    return [];
  }

  private async identifySuccessFactors(analytics: ComprehensiveAnalytics): Promise<SuccessFactor[]> {
    // Implementation for identifying success factors
    return [];
  }

  private async generateRiskMitigationStrategies(analytics: ComprehensiveAnalytics): Promise<RiskMitigationStrategy[]> {
    // Implementation for generating risk mitigation strategies
    return [];
  }

  private async identifyOptimizationOpportunities(analytics: ComprehensiveAnalytics): Promise<OptimizationOpportunity[]> {
    // Implementation for identifying optimization opportunities
    return [];
  }

  private async generateNextSteps(analytics: ComprehensiveAnalytics, predictive: PredictiveAnalytics): Promise<NextStep[]> {
    // Implementation for generating next steps
    return [];
  }

  private async generateLongTermStrategy(analytics: ComprehensiveAnalytics, predictive: PredictiveAnalytics): Promise<LongTermStrategy> {
    // Implementation for generating long-term strategy
    return {
      vision: '',
      goals: [],
      strategies: [],
      timeline: 0
    };
  }

  private async convertToCSV(data: any): Promise<string> {
    // Implementation for converting data to CSV
    return '';
  }

  private async generatePDF(data: any): Promise<Buffer> {
    // Implementation for generating PDF
    return Buffer.from('');
  }
}

// Type definitions
interface ComprehensiveAnalytics {
  workflowId: string;
  effectivenessScore: EffectivenessScore;
  insightMap: InsightMap;
  roiAnalysis: ROIAnalysis;
  benchmarkComparison: BenchmarkComparison;
  participantMetrics: ParticipantMetrics;
  phaseMetrics: PhaseMetrics;
  collaborationMetrics: CollaborationMetrics;
  outcomeMetrics: OutcomeMetrics;
  generatedAt: Date;
}

interface EffectivenessScore {
  overall: number;
  dimensions: {
    userCentricity: number;
    ideaDiversity: number;
    iterationSpeed: number;
    teamCollaboration: number;
    outcomeQuality: number;
    processAdherence: number;
  };
  recommendations: string[];
  benchmarks: BenchmarkComparison;
}

interface InsightMap {
  nodes: InsightNode[];
  edges: InsightEdge[];
  clusters: InsightCluster[];
  criticalPath: string[];
}

interface InsightNode {
  id: string;
  label: string;
  phase: string;
  importance: number;
  connections: string[];
}

interface InsightEdge {
  from: string;
  to: string;
  type: string;
  strength: number;
}

interface InsightCluster {
  id: string;
  name: string;
  insights: string[];
  theme: string;
}

interface InsightEvolution {
  originalInsight: Insight;
  transformations: InsightTransformation[];
  finalOutcome: Insight;
  impact: InsightImpact;
  businessValue: number;
}

interface InsightTransformation {
  phase: string;
  transformation: any;
  contributingFactors: string[];
  refinements: string[];
}

interface InsightImpact {
  usageCount: number;
  influenceScore: number;
  businessValue: number;
  timeToImpact: number;
}

interface ROIAnalysis {
  investment: {
    timeInvested: number;
    resourceCost: number;
    toolCost: number;
    total: number;
  };
  returns: {
    timeToMarketReduction: number;
    developmentCostSavings: number;
    revenueImpact: number;
    riskMitigation: number;
    innovationValue: number;
  };
  roi: number;
  paybackPeriod: number;
  intangibleBenefits: string[];
}

interface BenchmarkComparison {
  industry: string;
  similarProjects: number;
  performanceRanking: number;
  keyDifferences: string[];
  improvementOpportunities: string[];
}

interface ParticipantMetrics {
  totalParticipants: number;
  averageParticipationRate: number;
  averageContributionQuality: number;
  averageEngagementScore: number;
  participationDistribution: Distribution;
  topContributors: TopContributor[];
  engagementTrends: EngagementTrend[];
}

interface Distribution {
  low: number;
  medium: number;
  high: number;
}

interface TopContributor {
  participantId: string;
  contributionQuality: number;
  participationRate: number;
}

interface EngagementTrend {
  date: Date;
  engagementScore: number;
}

interface PhaseMetrics {
  phases: PhaseMetric[];
  overallProgress: number;
  phaseTransitions: PhaseTransition[];
  bottlenecks: Bottleneck[];
  recommendations: string[];
}

interface PhaseMetric {
  phase: string;
  duration: number;
  activities: number;
  participants: number;
  quality: number;
  progress: number;
}

interface PhaseTransition {
  from: string;
  to: string;
  duration: number;
  quality: number;
}

interface Bottleneck {
  phase: string;
  duration: number;
  severity: 'low' | 'medium' | 'high';
}

interface CollaborationMetrics {
  totalSessions: number;
  averageSessionDuration: number;
  collaborationQuality: number;
  conflictResolutionRate: number;
  realTimeUsage: number;
  mobileUsage: number;
  offlineUsage: number;
  teamDynamics: TeamDynamics;
}

interface TeamDynamics {
  communicationQuality: number;
  conflictResolution: number;
  collaborationEffectiveness: number;
  leadershipDistribution: number;
}

interface OutcomeMetrics {
  totalOutcomes: number;
  prototypeSuccessRate: number;
  testEffectiveness: number;
  ideaToPrototypeRate: number;
  prototypeToTestRate: number;
  timeToInsight: number;
  businessImpact: BusinessImpact;
  userSatisfaction: number;
}

interface BusinessImpact {
  revenue: number;
  costReduction: number;
  customerSatisfaction: number;
  competitiveAdvantage: number;
  marketOpportunity: number;
}

interface PredictiveAnalytics {
  successProbability: number;
  estimatedCompletionTime: number;
  resourceRequirements: ResourceRequirements;
  riskFactors: RiskFactor[];
  opportunityAreas: OpportunityArea[];
  recommendations: string[];
}

interface ResourceRequirements {
  time: number;
  people: number;
  budget: number;
}

interface RiskFactor {
  factor: string;
  probability: number;
  impact: number;
  mitigation: string;
}

interface OpportunityArea {
  area: string;
  potential: number;
  effort: number;
  recommendation: string;
}

interface InsightsAndRecommendations {
  keyInsights: KeyInsight[];
  improvementAreas: ImprovementArea[];
  successFactors: SuccessFactor[];
  riskMitigation: RiskMitigationStrategy[];
  optimizationOpportunities: OptimizationOpportunity[];
  nextSteps: NextStep[];
  longTermStrategy: LongTermStrategy;
}

interface KeyInsight {
  insight: string;
  importance: number;
  evidence: string[];
}

interface ImprovementArea {
  area: string;
  currentState: number;
  targetState: number;
  recommendations: string[];
}

interface SuccessFactor {
  factor: string;
  impact: number;
  evidence: string[];
}

interface RiskMitigationStrategy {
  risk: string;
  strategy: string;
  implementation: string[];
}

interface OptimizationOpportunity {
  opportunity: string;
  potential: number;
  effort: number;
  recommendation: string;
}

interface NextStep {
  action: string;
  priority: 'high' | 'medium' | 'low';
  timeline: string;
  resources: string[];
}

interface LongTermStrategy {
  vision: string;
  goals: string[];
  strategies: string[];
  timeline: number;
}

interface ExportData {
  format: string;
  data: string | Buffer;
  filename: string;
}

// Supporting interfaces
interface Activity {
  id: string;
  participantId: string;
  type: string;
  qualityScore?: number;
  engagementScore?: number;
  timestamp: Date;
}

interface ParticipationRate {
  participantId: string;
  participationRate: number;
  contributionQuality: number;
  engagementScore: number;
}

interface Collaboration {
  id: string;
  qualityScore?: number;
  conflicts?: Conflict[];
  resolvedConflicts?: Conflict[];
}

interface Conflict {
  id: string;
  type: string;
  description: string;
}

interface Session {
  id: string;
  duration: number;
  realTime: boolean;
  mobile: boolean;
  offline: boolean;
}

interface Prototype {
  id: string;
  success: boolean;
}

interface Test {
  id: string;
  effective: boolean;
}

interface Outcome {
  id: string;
  satisfactionScore?: number;
}

interface Workflow {
  id: string;
  name: string;
  currentPhase: string;
}

interface Insight {
  id: string;
  content: string;
  phase: string;
  importance: number;
}


===== FILE: server/services/dt-analytics-engine.ts =====
import { DatabaseService } from './database-service';

/**
 * Design Thinking Analytics Engine
 * 
 * Provides comprehensive analytics for DT workflows:
 * - Effectiveness measurement
 * - Insight mapping
 * - Benchmark comparison
 * - Predictive analytics
 */
export class DTAnalyticsEngine {
  private db: DatabaseService;

  constructor() {
    this.db = new DatabaseService();
  }

  /**
   * Calculate comprehensive effectiveness score
   */
  async calculateEffectivenessScore(workflowId: string): Promise<EffectivenessScore> {
    try {
      const workflow = await this.db.getWorkflow(workflowId);
      if (!workflow) {
        throw new Error('Workflow not found');
      }

      // Get all analytics data
      const [
        userCentricity,
        ideaDiversity,
        iterationSpeed,
        teamCollaboration,
        outcomeQuality,
        processAdherence
      ] = await Promise.all([
        this.measureUserCentricity(workflowId),
        this.measureIdeaDiversity(workflowId),
        this.measureIterationSpeed(workflowId),
        this.measureTeamCollaboration(workflowId),
        this.measureOutcomeQuality(workflowId),
        this.measureProcessAdherence(workflowId)
      ]);

      // Calculate overall score
      const overall = this.calculateOverallScore({
        userCentricity,
        ideaDiversity,
        iterationSpeed,
        teamCollaboration,
        outcomeQuality,
        processAdherence
      });

      // Generate recommendations
      const recommendations = await this.generateRecommendations(workflowId, {
        userCentricity,
        ideaDiversity,
        iterationSpeed,
        teamCollaboration,
        outcomeQuality,
        processAdherence
      });

      return {
        overall,
        dimensions: {
          userCentricity,
          ideaDiversity,
          iterationSpeed,
          teamCollaboration,
          outcomeQuality,
          processAdherence
        },
        recommendations,
        benchmarks: await this.compareToBenchmarks(workflowId),
        calculatedAt: new Date()
      };
    } catch (error) {
      console.error('Error calculating effectiveness score:', error);
      throw new Error('Failed to calculate effectiveness score');
    }
  }

  /**
   * Generate insight map for workflow
   */
  async generateInsightMap(workflowId: string): Promise<InsightMap> {
    try {
      const insights = await this.getWorkflowInsights(workflowId);
      const relationships = await this.identifyRelationships(insights);
      const clusters = await this.clusterInsights(insights);
      const criticalPath = await this.identifyCriticalPath(insights);

      return {
        nodes: insights.map(insight => ({
          id: insight.id,
          label: insight.content,
          phase: insight.phase,
          importance: insight.importance,
          connections: insight.connections || []
        })),
        edges: relationships,
        clusters,
        criticalPath,
        generatedAt: new Date()
      };
    } catch (error) {
      console.error('Error generating insight map:', error);
      throw new Error('Failed to generate insight map');
    }
  }

  /**
   * Compare workflow to benchmarks
   */
  async compareToBenchmarks(workflowId: string): Promise<BenchmarkComparison> {
    try {
      const workflow = await this.db.getWorkflow(workflowId);
      if (!workflow) {
        throw new Error('Workflow not found');
      }

      const benchmarks = await this.findBenchmarks(workflow);
      const comparison = await this.performComparison(workflow, benchmarks);

      return {
        industry: workflow.industry || 'general',
        similarProjects: benchmarks.length,
        performanceRanking: comparison.ranking,
        keyDifferences: comparison.differences,
        improvementOpportunities: comparison.opportunities,
        comparedAt: new Date()
      };
    } catch (error) {
      console.error('Error comparing to benchmarks:', error);
      throw new Error('Failed to compare to benchmarks');
    }
  }

  /**
   * Measure user centricity
   */
  private async measureUserCentricity(workflowId: string): Promise<number> {
    try {
      const empathyData = await this.db.getEmpathyData(workflowId);
      const userInterviews = await this.db.getUserInterviews(workflowId);
      const personaQuality = await this.assessPersonaQuality(empathyData);
      const interviewDepth = await this.assessInterviewDepth(userInterviews);

      return (personaQuality + interviewDepth) / 2;
    } catch (error) {
      console.error('Error measuring user centricity:', error);
      return 0;
    }
  }

  /**
   * Measure idea diversity
   */
  private async measureIdeaDiversity(workflowId: string): Promise<number> {
    try {
      const ideas = await this.db.getWorkflowIdeas(workflowId);
      const diversityScore = await this.calculateIdeaDiversity(ideas);
      return diversityScore;
    } catch (error) {
      console.error('Error measuring idea diversity:', error);
      return 0;
    }
  }

  /**
   * Measure iteration speed
   */
  private async measureIterationSpeed(workflowId: string): Promise<number> {
    try {
      const iterations = await this.db.getWorkflowIterations(workflowId);
      const speedScore = await this.calculateIterationSpeed(iterations);
      return speedScore;
    } catch (error) {
      console.error('Error measuring iteration speed:', error);
      return 0;
    }
  }

  /**
   * Measure team collaboration
   */
  private async measureTeamCollaboration(workflowId: string): Promise<number> {
    try {
      const sessions = await this.db.getWorkflowSessions(workflowId);
      const collaborationScore = await this.calculateCollaborationScore(sessions);
      return collaborationScore;
    } catch (error) {
      console.error('Error measuring team collaboration:', error);
      return 0;
    }
  }

  /**
   * Measure outcome quality
   */
  private async measureOutcomeQuality(workflowId: string): Promise<number> {
    try {
      const outcomes = await this.db.getWorkflowOutcomes(workflowId);
      const qualityScore = await this.calculateOutcomeQuality(outcomes);
      return qualityScore;
    } catch (error) {
      console.error('Error measuring outcome quality:', error);
      return 0;
    }
  }

  /**
   * Measure process adherence
   */
  private async measureProcessAdherence(workflowId: string): Promise<number> {
    try {
      const workflow = await this.db.getWorkflow(workflowId);
      const adherenceScore = await this.calculateProcessAdherence(workflow);
      return adherenceScore;
    } catch (error) {
      console.error('Error measuring process adherence:', error);
      return 0;
    }
  }

  /**
   * Calculate overall score
   */
  private calculateOverallScore(dimensions: EffectivenessDimensions): number {
    const weights = {
      userCentricity: 0.2,
      ideaDiversity: 0.15,
      iterationSpeed: 0.15,
      teamCollaboration: 0.2,
      outcomeQuality: 0.2,
      processAdherence: 0.1
    };

    return Object.entries(dimensions).reduce((sum, [key, value]) => {
      return sum + (value * (weights[key as keyof typeof weights] || 0));
    }, 0);
  }

  /**
   * Generate recommendations
   */
  private async generateRecommendations(workflowId: string, dimensions: EffectivenessDimensions): Promise<string[]> {
    const recommendations: string[] = [];

    if (dimensions.userCentricity < 0.6) {
      recommendations.push('Increase user research depth and persona development');
    }

    if (dimensions.ideaDiversity < 0.6) {
      recommendations.push('Encourage more diverse idea generation techniques');
    }

    if (dimensions.iterationSpeed < 0.6) {
      recommendations.push('Optimize iteration cycles and feedback loops');
    }

    if (dimensions.teamCollaboration < 0.6) {
      recommendations.push('Improve team collaboration and communication');
    }

    if (dimensions.outcomeQuality < 0.6) {
      recommendations.push('Focus on higher quality deliverables and outcomes');
    }

    if (dimensions.processAdherence < 0.6) {
      recommendations.push('Better adherence to Design Thinking methodology');
    }

    return recommendations;
  }

  /**
   * Get workflow insights
   */
  private async getWorkflowInsights(workflowId: string): Promise<Insight[]> {
    return await this.db.getWorkflowInsights(workflowId);
  }

  /**
   * Identify relationships between insights
   */
  private async identifyRelationships(insights: Insight[]): Promise<InsightEdge[]> {
    const edges: InsightEdge[] = [];

    for (let i = 0; i < insights.length; i++) {
      for (let j = i + 1; j < insights.length; j++) {
        const similarity = await this.calculateInsightSimilarity(insights[i], insights[j]);
        if (similarity > 0.5) {
          edges.push({
            from: insights[i].id,
            to: insights[j].id,
            type: 'related',
            strength: similarity
          });
        }
      }
    }

    return edges;
  }

  /**
   * Cluster insights
   */
  private async clusterInsights(insights: Insight[]): Promise<InsightCluster[]> {
    const clusters: InsightCluster[] = [];
    const processed = new Set<string>();

    for (const insight of insights) {
      if (processed.has(insight.id)) continue;

      const cluster = await this.createInsightCluster(insight, insights);
      clusters.push(cluster);
      
      cluster.insights.forEach(id => processed.add(id));
    }

    return clusters;
  }

  /**
   * Identify critical path
   */
  private async identifyCriticalPath(insights: Insight[]): Promise<string[]> {
    const sortedInsights = insights.sort((a, b) => (b.importance || 0) - (a.importance || 0));
    return sortedInsights.slice(0, 5).map(insight => insight.id);
  }

  /**
   * Calculate insight similarity
   */
  private async calculateInsightSimilarity(insight1: Insight, insight2: Insight): Promise<number> {
    // Simple similarity calculation based on content and phase
    const contentSimilarity = this.calculateContentSimilarity(insight1.content, insight2.content);
    const phaseSimilarity = insight1.phase === insight2.phase ? 1 : 0;
    
    return (contentSimilarity + phaseSimilarity) / 2;
  }

  /**
   * Calculate content similarity
   */
  private calculateContentSimilarity(content1: string, content2: string): number {
    // Simple word-based similarity
    const words1 = content1.toLowerCase().split(/\s+/);
    const words2 = content2.toLowerCase().split(/\s+/);
    
    const intersection = words1.filter(word => words2.includes(word));
    const union = [...new Set([...words1, ...words2])];
    
    return intersection.length / union.length;
  }

  /**
   * Create insight cluster
   */
  private async createInsightCluster(seedInsight: Insight, allInsights: Insight[]): Promise<InsightCluster> {
    const cluster: InsightCluster = {
      id: this.generateId(),
      name: `Cluster ${seedInsight.phase}`,
      insights: [seedInsight.id],
      theme: seedInsight.phase,
      confidence: 0.8
    };

    for (const insight of allInsights) {
      if (insight.id === seedInsight.id) continue;
      
      const similarity = await this.calculateInsightSimilarity(seedInsight, insight);
      if (similarity > 0.6) {
        cluster.insights.push(insight.id);
      }
    }

    return cluster;
  }

  /**
   * Find benchmarks
   */
  private async findBenchmarks(workflow: Workflow): Promise<Benchmark[]> {
    return await this.db.findSimilarWorkflows(workflow);
  }

  /**
   * Perform comparison
   */
  private async performComparison(workflow: Workflow, benchmarks: Benchmark[]): Promise<ComparisonResult> {
    // Implementation for comparing workflow to benchmarks
    return {
      ranking: 0.5,
      differences: [],
      opportunities: []
    };
  }

  /**
   * Generate unique ID
   */
  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }

  // Placeholder methods for database operations
  private async assessPersonaQuality(empathyData: any[]): Promise<number> { return 0.8; }
  private async assessInterviewDepth(interviews: any[]): Promise<number> { return 0.7; }
  private async calculateIdeaDiversity(ideas: any[]): Promise<number> { return 0.6; }
  private async calculateIterationSpeed(iterations: any[]): Promise<number> { return 0.5; }
  private async calculateCollaborationScore(sessions: any[]): Promise<number> { return 0.7; }
  private async calculateOutcomeQuality(outcomes: any[]): Promise<number> { return 0.8; }
  private async calculateProcessAdherence(workflow: any): Promise<number> { return 0.6; }
}

// Type definitions
interface EffectivenessScore {
  overall: number;
  dimensions: EffectivenessDimensions;
  recommendations: string[];
  benchmarks: BenchmarkComparison;
  calculatedAt: Date;
}

interface EffectivenessDimensions {
  userCentricity: number;
  ideaDiversity: number;
  iterationSpeed: number;
  teamCollaboration: number;
  outcomeQuality: number;
  processAdherence: number;
}

interface InsightMap {
  nodes: InsightNode[];
  edges: InsightEdge[];
  clusters: InsightCluster[];
  criticalPath: string[];
  generatedAt: Date;
}

interface InsightNode {
  id: string;
  label: string;
  phase: string;
  importance: number;
  connections: string[];
}

interface InsightEdge {
  from: string;
  to: string;
  type: string;
  strength: number;
}

interface InsightCluster {
  id: string;
  name: string;
  insights: string[];
  theme: string;
  confidence: number;
}

interface BenchmarkComparison {
  industry: string;
  similarProjects: number;
  performanceRanking: number;
  keyDifferences: string[];
  improvementOpportunities: string[];
  comparedAt: Date;
}

interface Insight {
  id: string;
  content: string;
  phase: string;
  importance: number;
  connections?: string[];
}

interface Workflow {
  id: string;
  industry?: string;
}

interface Benchmark {
  id: string;
  industry: string;
  metrics: any;
}

interface ComparisonResult {
  ranking: number;
  differences: string[];
  opportunities: string[];
}


