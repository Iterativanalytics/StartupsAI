import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Badge } from '@/components/ui/badge';
import { 
  Save, 
  Download, 
  Lightbulb, 
  Target, 
  TrendingUp,
  RefreshCw,
  Vote,
  Star,
  CheckCircle,
  AlertTriangle
} from 'lucide-react';

export interface HMWQuestionData {
  id: string;
  question: string;
  reframingType: 'amplify' | 'remove-constraint' | 'opposite' | 'question-assumption' | 'resource-change';
  desirability: number; // 1-5
  feasibility: number; // 1-5
  viability: number; // 1-5
  ideaCount: number;
  createdAt?: Date;
  updatedAt?: Date;
}

interface HMWQuestionGeneratorProps {
  projectId: string;
  povStatement: string;
  initialData?: HMWQuestionData[];
  onSave: (data: HMWQuestionData[]) => void;
  onExport?: (data: HMWQuestionData[]) => void;
}

const reframingTechniques = {
  amplify: {
    name: 'Amplify',
    description: 'Make the problem bigger or more extreme',
    example: 'How might we eliminate the need for parking entirely?'
  },
  'remove-constraint': {
    name: 'Remove Constraint',
    description: 'Remove an assumed limitation',
    example: 'How might we deliver value without an app?'
  },
  opposite: {
    name: 'Opposite',
    description: 'Flip the problem',
    example: 'How might we encourage customers to complain more?'
  },
  'question-assumption': {
    name: 'Question Assumption',
    description: 'Challenge implicit beliefs',
    example: 'How might we deliver value without requiring sign-up?'
  },
  'resource-change': {
    name: 'Resource Change',
    description: 'Change who has resources',
    example: 'How might customers support each other?'
  }
};

const autoGeneratedQuestions = [
  'How might we make this process effortless?',
  'How might we eliminate this problem entirely?',
  'How might we turn this into an opportunity?',
  'How might we make this delightful?',
  'How might we remove all friction?',
  'How might we make this instant?',
  'How might we make this personal?',
  'How might we make this social?',
  'How might we make this sustainable?',
  'How might we make this accessible?'
];

export function HMWQuestionGenerator({ 
  projectId, 
  povStatement,
  initialData = [], 
  onSave, 
  onExport 
}: HMWQuestionGeneratorProps) {
  const [questions, setQuestions] = useState<HMWQuestionData[]>(initialData);
  const [isSaving, setIsSaving] = useState(false);
  const [newQuestion, setNewQuestion] = useState('');
  const [selectedTechnique, setSelectedTechnique] = useState<keyof typeof reframingTechniques>('amplify');

  useEffect(() => {
    if (initialData.length > 0) {
      setQuestions(initialData);
    }
  }, [initialData]);

  const generateQuestions = () => {
    const newQuestions: HMWQuestionData[] = autoGeneratedQuestions.slice(0, 5).map((question, index) => ({
      id: `generated-${Date.now()}-${index}`,
      question,
      reframingType: Object.keys(reframingTechniques)[index % Object.keys(reframingTechniques).length] as keyof typeof reframingTechniques,
      desirability: Math.floor(Math.random() * 3) + 3, // 3-5
      feasibility: Math.floor(Math.random() * 3) + 3, // 3-5
      viability: Math.floor(Math.random() * 3) + 3, // 3-5
      ideaCount: 0
    }));

    setQuestions(prev => [...prev, ...newQuestions]);
  };

  const addQuestion = () => {
    if (newQuestion.trim()) {
      const question: HMWQuestionData = {
        id: `manual-${Date.now()}`,
        question: newQuestion.trim(),
        reframingType: selectedTechnique,
        desirability: 3,
        feasibility: 3,
        viability: 3,
        ideaCount: 0
      };
      
      setQuestions(prev => [...prev, question]);
      setNewQuestion('');
    }
  };

  const updateQuestion = (id: string, field: keyof HMWQuestionData, value: any) => {
    setQuestions(prev => prev.map(q => 
      q.id === id ? { ...q, [field]: value } : q
    ));
  };

  const removeQuestion = (id: string) => {
    setQuestions(prev => prev.filter(q => q.id !== id));
  };

  const applyReframing = (question: HMWQuestionData, technique: keyof typeof reframingTechniques) => {
    const baseQuestion = question.question;
    let reframedQuestion = baseQuestion;

    switch (technique) {
      case 'amplify':
        reframedQuestion = baseQuestion.replace(/make|improve|help/g, 'eliminate');
        reframedQuestion = reframedQuestion.replace(/better|easier|faster/g, 'entirely');
        break;
      case 'remove-constraint':
        reframedQuestion = baseQuestion.replace(/with|using|through/g, 'without');
        break;
      case 'opposite':
        reframedQuestion = baseQuestion.replace(/reduce|minimize|decrease/g, 'increase');
        reframedQuestion = reframedQuestion.replace(/increase|maximize|enhance/g, 'reduce');
        break;
      case 'question-assumption':
        reframedQuestion = baseQuestion.replace(/we|our|the system/g, 'users themselves');
        break;
      case 'resource-change':
        reframedQuestion = baseQuestion.replace(/we|our|the company/g, 'users');
        break;
    }

    updateQuestion(question.id, 'question', reframedQuestion);
    updateQuestion(question.id, 'reframingType', technique);
  };

  const handleSave = async () => {
    setIsSaving(true);
    try {
      await onSave(questions);
    } catch (error) {
      console.error('Error saving HMW questions:', error);
    } finally {
      setIsSaving(false);
    }
  };

  const handleExport = () => {
    if (onExport) {
      onExport(questions);
    }
  };

  const getPriorityScore = (question: HMWQuestionData) => {
    return (question.desirability + question.feasibility + question.viability) / 3;
  };

  const getPriorityColor = (score: number) => {
    if (score >= 4) return 'text-green-600';
    if (score >= 3) return 'text-yellow-600';
    return 'text-red-600';
  };

  const getPriorityIcon = (score: number) => {
    if (score >= 4) return CheckCircle;
    if (score >= 3) return AlertTriangle;
    return AlertTriangle;
  };

  const sortedQuestions = [...questions].sort((a, b) => getPriorityScore(b) - getPriorityScore(a));

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-bold">HMW Question Generator</h2>
          <p className="text-gray-600 mt-1">
            Generate "How Might We" questions to reframe your problem and spark innovative solutions
          </p>
        </div>
        <div className="flex gap-2">
          <Button 
            onClick={handleSave} 
            disabled={isSaving}
            className="flex items-center gap-2"
          >
            <Save className="w-4 h-4" />
            {isSaving ? 'Saving...' : 'Save'}
          </Button>
          {onExport && (
            <Button 
              variant="outline" 
              onClick={handleExport}
              className="flex items-center gap-2"
            >
              <Download className="w-4 h-4" />
              Export
            </Button>
          )}
        </div>
      </div>

      {/* POV Statement Context */}
      {povStatement && (
        <Card className="bg-blue-50 border-blue-200">
          <CardHeader>
            <CardTitle className="flex items-center gap-2 text-blue-900">
              <Target className="w-5 h-5" />
              POV Statement Context
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-blue-800">{povStatement}</p>
          </CardContent>
        </Card>
      )}

      {/* Generate Questions */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Lightbulb className="w-5 h-5" />
            Generate Questions
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex gap-2">
            <Button onClick={generateQuestions} className="flex items-center gap-2">
              <RefreshCw className="w-4 h-4" />
              Generate 5 Questions
            </Button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium mb-2">Add Custom Question</label>
              <Textarea
                placeholder="How might we..."
                value={newQuestion}
                onChange={(e) => setNewQuestion(e.target.value)}
                className="min-h-[80px]"
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-2">Reframing Technique</label>
              <select
                value={selectedTechnique}
                onChange={(e) => setSelectedTechnique(e.target.value as keyof typeof reframingTechniques)}
                className="w-full px-3 py-2 border rounded-md"
              >
                {Object.entries(reframingTechniques).map(([key, technique]) => (
                  <option key={key} value={key}>{technique.name}</option>
                ))}
              </select>
              <p className="text-xs text-gray-600 mt-1">
                {reframingTechniques[selectedTechnique].description}
              </p>
            </div>
          </div>

          <Button onClick={addQuestion} disabled={!newQuestion.trim()}>
            Add Custom Question
          </Button>
        </CardContent>
      </Card>

      {/* Reframing Techniques Guide */}
      <Card className="bg-gray-50">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <TrendingUp className="w-5 h-5" />
            Reframing Techniques
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {Object.entries(reframingTechniques).map(([key, technique]) => (
              <div key={key} className="p-3 bg-white rounded border">
                <h4 className="font-medium text-sm">{technique.name}</h4>
                <p className="text-xs text-gray-600 mt-1">{technique.description}</p>
                <p className="text-xs text-blue-600 mt-2 italic">"{technique.example}"</p>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* Questions List */}
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold">Generated Questions ({questions.length})</h3>
          <Badge variant="outline" className="flex items-center gap-1">
            <Star className="w-3 h-3" />
            Sorted by Priority
          </Badge>
        </div>

        {sortedQuestions.map((question, index) => {
          const priorityScore = getPriorityScore(question);
          const PriorityIcon = getPriorityIcon(priorityScore);
          
          return (
            <Card key={question.id} className="border-2 border-gray-200">
              <CardHeader>
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-2">
                      <Badge variant="outline">#{index + 1}</Badge>
                      <Badge variant="secondary">{reframingTechniques[question.reframingType].name}</Badge>
                      <div className="flex items-center gap-1">
                        <PriorityIcon className={`w-4 h-4 ${getPriorityColor(priorityScore)}`} />
                        <span className={`text-sm font-medium ${getPriorityColor(priorityScore)}`}>
                          {priorityScore.toFixed(1)}/5
                        </span>
                      </div>
                    </div>
                    <p className="text-lg font-medium">{question.question}</p>
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => removeQuestion(question.id)}
                    className="text-red-600 hover:text-red-700"
                  >
                    <X className="w-4 h-4" />
                  </Button>
                </div>
              </CardHeader>
              <CardContent className="space-y-4">
                {/* Scoring */}
                <div className="grid grid-cols-3 gap-4">
                  <div>
                    <label className="block text-sm font-medium mb-1">Desirability</label>
                    <select
                      value={question.desirability}
                      onChange={(e) => updateQuestion(question.id, 'desirability', parseInt(e.target.value))}
                      className="w-full px-2 py-1 border rounded text-sm"
                    >
                      <option value={1}>1 - Low</option>
                      <option value={2}>2 - Below Average</option>
                      <option value={3}>3 - Average</option>
                      <option value={4}>4 - High</option>
                      <option value={5}>5 - Very High</option>
                    </select>
                  </div>
                  <div>
                    <label className="block text-sm font-medium mb-1">Feasibility</label>
                    <select
                      value={question.feasibility}
                      onChange={(e) => updateQuestion(question.id, 'feasibility', parseInt(e.target.value))}
                      className="w-full px-2 py-1 border rounded text-sm"
                    >
                      <option value={1}>1 - Low</option>
                      <option value={2}>2 - Below Average</option>
                      <option value={3}>3 - Average</option>
                      <option value={4}>4 - High</option>
                      <option value={5}>5 - Very High</option>
                    </select>
                  </div>
                  <div>
                    <label className="block text-sm font-medium mb-1">Viability</label>
                    <select
                      value={question.viability}
                      onChange={(e) => updateQuestion(question.id, 'viability', parseInt(e.target.value))}
                      className="w-full px-2 py-1 border rounded text-sm"
                    >
                      <option value={1}>1 - Low</option>
                      <option value={2}>2 - Below Average</option>
                      <option value={3}>3 - Average</option>
                      <option value={4}>4 - High</option>
                      <option value={5}>5 - Very High</option>
                    </select>
                  </div>
                </div>

                {/* Reframing Actions */}
                <div className="flex flex-wrap gap-2">
                  {Object.keys(reframingTechniques).map(technique => (
                    <Button
                      key={technique}
                      variant="outline"
                      size="sm"
                      onClick={() => applyReframing(question, technique as keyof typeof reframingTechniques)}
                      className="text-xs"
                    >
                      {reframingTechniques[technique as keyof typeof reframingTechniques].name}
                    </Button>
                  ))}
                </div>

                {/* Idea Count */}
                <div className="flex items-center gap-2">
                  <label className="text-sm font-medium">Ideas Generated:</label>
                  <Input
                    type="number"
                    value={question.ideaCount}
                    onChange={(e) => updateQuestion(question.id, 'ideaCount', parseInt(e.target.value) || 0)}
                    className="w-20"
                    min="0"
                  />
                </div>
              </CardContent>
            </Card>
          );
        })}
      </div>

      {/* Prioritization Matrix */}
      {questions.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Vote className="w-5 h-5" />
              Prioritization Matrix
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <h4 className="font-medium text-green-600">High Priority (4-5 stars)</h4>
                {sortedQuestions.filter(q => getPriorityScore(q) >= 4).map(question => (
                  <div key={question.id} className="text-sm p-2 bg-green-50 rounded">
                    {question.question}
                  </div>
                ))}
              </div>
              <div className="space-y-2">
                <h4 className="font-medium text-yellow-600">Medium Priority (3-4 stars)</h4>
                {sortedQuestions.filter(q => getPriorityScore(q) >= 3 && getPriorityScore(q) < 4).map(question => (
                  <div key={question.id} className="text-sm p-2 bg-yellow-50 rounded">
                    {question.question}
                  </div>
                ))}
              </div>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Tips and Guidance */}
      <Card className="bg-blue-50 border-blue-200">
        <CardContent className="pt-6">
          <h3 className="font-semibold text-blue-900 mb-2">ðŸ’¡ Tips for Better HMW Questions</h3>
          <ul className="text-sm text-blue-800 space-y-1">
            <li>â€¢ Start with "How might we..." to keep questions open-ended</li>
            <li>â€¢ Focus on the user's need, not your solution</li>
            <li>â€¢ Make questions specific enough to be actionable</li>
            <li>â€¢ Use reframing techniques to explore different angles</li>
            <li>â€¢ Prioritize questions that are desirable, feasible, and viable</li>
            <li>â€¢ Generate many questions before evaluating them</li>
          </ul>
        </CardContent>
      </Card>
    </div>
  );
}
