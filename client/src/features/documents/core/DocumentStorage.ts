import { BaseDocument, DocumentType, DocumentSearchQuery, DocumentSearchResult, DocumentTemplate } from '../types/document.types';

/**
 * Document Storage - Handles document persistence and retrieval
 * 
 * This storage layer provides:
 * - Document CRUD operations
 * - Search and filtering
 * - Template management
 * - Caching and optimization
 * - Backup and recovery
 */
export class DocumentStorage {
  private documents: Map<string, BaseDocument> = new Map();
  private templates: Map<string, DocumentTemplate> = new Map();
  private indexes: Map<string, Set<string>> = new Map();
  private cache: Map<string, any> = new Map();
  private cacheExpiry: Map<string, number> = new Map();

  constructor() {
    this.initializeIndexes();
  }

  /**
   * Save a document
   */
  async save(document: BaseDocument): Promise<void> {
    // Validate document
    if (!document.id || !document.type) {
      throw new Error('Invalid document: missing required fields');
    }

    // Update indexes
    this.updateIndexes(document);

    // Store document
    this.documents.set(document.id, document);

    // Update cache
    this.cache.set(`document:${document.id}`, document);
    this.cacheExpiry.set(`document:${document.id}`, Date.now() + 300000); // 5 minutes

    // Emit storage event
    this.emitStorageEvent('document:saved', { document });
  }

  /**
   * Get a document by ID
   */
  async get(id: string): Promise<BaseDocument | null> {
    // Check cache first
    const cached = this.cache.get(`document:${id}`);
    if (cached && this.cacheExpiry.get(`document:${id}`) > Date.now()) {
      return cached;
    }

    // Get from storage
    const document = this.documents.get(id);
    if (!document) {
      return null;
    }

    // Update cache
    this.cache.set(`document:${id}`, document);
    this.cacheExpiry.set(`document:${id}`, Date.now() + 300000);

    return document;
  }

  /**
   * Get multiple documents by IDs
   */
  async getMany(ids: string[]): Promise<BaseDocument[]> {
    const documents: BaseDocument[] = [];
    
    for (const id of ids) {
      const document = await this.get(id);
      if (document) {
        documents.push(document);
      }
    }

    return documents;
  }

  /**
   * Delete a document
   */
  async delete(id: string): Promise<void> {
    const document = this.documents.get(id);
    if (!document) {
      throw new Error(`Document not found: ${id}`);
    }

    // Remove from indexes
    this.removeFromIndexes(document);

    // Remove from storage
    this.documents.delete(id);

    // Remove from cache
    this.cache.delete(`document:${id}`);
    this.cacheExpiry.delete(`document:${id}`);

    // Emit storage event
    this.emitStorageEvent('document:deleted', { document });
  }

  /**
   * Search documents
   */
  async search(query: DocumentSearchQuery): Promise<DocumentSearchResult> {
    const {
      text,
      type,
      category,
      tags,
      status,
      createdBy,
      dateRange,
      aiGenerated,
      limit = 50,
      offset = 0,
      sortBy = 'updatedAt',
      sortOrder = 'desc'
    } = query;

    let results = Array.from(this.documents.values());

    // Apply filters
    if (type) {
      results = results.filter(doc => doc.type === type);
    }

    if (category) {
      results = results.filter(doc => doc.metadata.category === category);
    }

    if (tags && tags.length > 0) {
      results = results.filter(doc => 
        tags.some(tag => doc.metadata.tags.includes(tag))
      );
    }

    if (status) {
      results = results.filter(doc => doc.metadata.status === status);
    }

    if (createdBy) {
      results = results.filter(doc => doc.createdBy === createdBy);
    }

    if (dateRange) {
      results = results.filter(doc => 
        doc.createdAt >= dateRange.start && doc.createdAt <= dateRange.end
      );
    }

    if (aiGenerated !== undefined) {
      results = results.filter(doc => doc.ai.autoGenerated === aiGenerated);
    }

    // Apply text search
    if (text) {
      const searchText = text.toLowerCase();
      results = results.filter(doc => 
        doc.title.toLowerCase().includes(searchText) ||
        doc.description?.toLowerCase().includes(searchText) ||
        doc.metadata.tags.some(tag => tag.toLowerCase().includes(searchText))
      );
    }

    // Sort results
    results.sort((a, b) => {
      const aValue = this.getSortValue(a, sortBy);
      const bValue = this.getSortValue(b, sortBy);
      
      if (sortOrder === 'asc') {
        return aValue > bValue ? 1 : -1;
      } else {
        return aValue < bValue ? 1 : -1;
      }
    });

    // Apply pagination
    const total = results.length;
    const documents = results.slice(offset, offset + limit);

    // Generate facets
    const facets = this.generateFacets(results);

    // Generate suggestions
    const suggestions = this.generateSuggestions(text, results);

    return {
      documents,
      total,
      facets,
      suggestions
    };
  }

  /**
   * Get document templates
   */
  async getTemplates(type?: DocumentType): Promise<DocumentTemplate[]> {
    let templates = Array.from(this.templates.values());

    if (type) {
      templates = templates.filter(template => template.type === type);
    }

    return templates.sort((a, b) => b.usageCount - a.usageCount);
  }

  /**
   * Get template by ID
   */
  async getTemplate(templateId: string): Promise<DocumentTemplate | null> {
    return this.templates.get(templateId) || null;
  }

  /**
   * Save a template
   */
  async saveTemplate(template: DocumentTemplate): Promise<void> {
    this.templates.set(template.id, template);
    this.emitStorageEvent('template:saved', { template });
  }

  /**
   * Delete a template
   */
  async deleteTemplate(templateId: string): Promise<void> {
    this.templates.delete(templateId);
    this.emitStorageEvent('template:deleted', { templateId });
  }

  /**
   * Get document statistics
   */
  async getStats(): Promise<{
    totalDocuments: number;
    documentsByType: Record<DocumentType, number>;
    documentsByStatus: Record<string, number>;
    totalTemplates: number;
    storageSize: number;
  }> {
    const stats = {
      totalDocuments: this.documents.size,
      documentsByType: {} as Record<DocumentType, number>,
      documentsByStatus: {} as Record<string, number>,
      totalTemplates: this.templates.size,
      storageSize: 0
    };

    // Count by type and status
    for (const document of this.documents.values()) {
      stats.documentsByType[document.type] = (stats.documentsByType[document.type] || 0) + 1;
      stats.documentsByStatus[document.metadata.status] = (stats.documentsByStatus[document.metadata.status] || 0) + 1;
    }

    // Calculate storage size (rough estimate)
    stats.storageSize = JSON.stringify(Array.from(this.documents.values())).length;

    return stats;
  }

  /**
   * Backup documents
   */
  async backup(): Promise<{
    documents: BaseDocument[];
    templates: DocumentTemplate[];
    timestamp: Date;
  }> {
    return {
      documents: Array.from(this.documents.values()),
      templates: Array.from(this.templates.values()),
      timestamp: new Date()
    };
  }

  /**
   * Restore documents from backup
   */
  async restore(backup: {
    documents: BaseDocument[];
    templates: DocumentTemplate[];
  }): Promise<void> {
    // Clear existing data
    this.documents.clear();
    this.templates.clear();
    this.cache.clear();
    this.cacheExpiry.clear();

    // Restore documents
    for (const document of backup.documents) {
      this.documents.set(document.id, document);
    }

    // Restore templates
    for (const template of backup.templates) {
      this.templates.set(template.id, template);
    }

    // Rebuild indexes
    this.initializeIndexes();
    for (const document of backup.documents) {
      this.updateIndexes(document);
    }

    this.emitStorageEvent('storage:restored', { backup });
  }

  /**
   * Clear all data
   */
  async clear(): Promise<void> {
    this.documents.clear();
    this.templates.clear();
    this.cache.clear();
    this.cacheExpiry.clear();
    this.initializeIndexes();
    this.emitStorageEvent('storage:cleared', {});
  }

  /**
   * Initialize search indexes
   */
  private initializeIndexes(): void {
    this.indexes.clear();
    this.indexes.set('type', new Set());
    this.indexes.set('category', new Set());
    this.indexes.set('status', new Set());
    this.indexes.set('createdBy', new Set());
    this.indexes.set('tags', new Set());
  }

  /**
   * Update search indexes
   */
  private updateIndexes(document: BaseDocument): void {
    // Update type index
    this.indexes.get('type')?.add(document.type);

    // Update category index
    this.indexes.get('category')?.add(document.metadata.category);

    // Update status index
    this.indexes.get('status')?.add(document.metadata.status);

    // Update createdBy index
    this.indexes.get('createdBy')?.add(document.createdBy);

    // Update tags index
    for (const tag of document.metadata.tags) {
      this.indexes.get('tags')?.add(tag);
    }
  }

  /**
   * Remove from search indexes
   */
  private removeFromIndexes(document: BaseDocument): void {
    // Note: In a real implementation, we'd need to check if other documents
    // still use these values before removing from indexes
    // For simplicity, we'll leave them in the indexes
  }

  /**
   * Get sort value for a document
   */
  private getSortValue(document: BaseDocument, sortBy: string): any {
    switch (sortBy) {
      case 'title':
        return document.title;
      case 'createdAt':
        return document.createdAt.getTime();
      case 'updatedAt':
        return document.updatedAt.getTime();
      case 'createdBy':
        return document.createdBy;
      case 'type':
        return document.type;
      case 'status':
        return document.metadata.status;
      default:
        return document.updatedAt.getTime();
    }
  }

  /**
   * Generate search facets
   */
  private generateFacets(documents: BaseDocument[]): any {
    const facets = {
      types: {} as Record<DocumentType, number>,
      categories: {} as Record<string, number>,
      tags: {} as Record<string, number>,
      statuses: {} as Record<string, number>,
      dateRanges: {} as Record<string, number>
    };

    for (const document of documents) {
      // Count by type
      facets.types[document.type] = (facets.types[document.type] || 0) + 1;

      // Count by category
      facets.categories[document.metadata.category] = (facets.categories[document.metadata.category] || 0) + 1;

      // Count by status
      facets.statuses[document.metadata.status] = (facets.statuses[document.metadata.status] || 0) + 1;

      // Count by tags
      for (const tag of document.metadata.tags) {
        facets.tags[tag] = (facets.tags[tag] || 0) + 1;
      }

      // Count by date ranges
      const now = new Date();
      const docDate = document.createdAt;
      const daysDiff = Math.floor((now.getTime() - docDate.getTime()) / (1000 * 60 * 60 * 24));

      if (daysDiff <= 7) {
        facets.dateRanges['last-week'] = (facets.dateRanges['last-week'] || 0) + 1;
      } else if (daysDiff <= 30) {
        facets.dateRanges['last-month'] = (facets.dateRanges['last-month'] || 0) + 1;
      } else if (daysDiff <= 90) {
        facets.dateRanges['last-quarter'] = (facets.dateRanges['last-quarter'] || 0) + 1;
      } else {
        facets.dateRanges['older'] = (facets.dateRanges['older'] || 0) + 1;
      }
    }

    return facets;
  }

  /**
   * Generate search suggestions
   */
  private generateSuggestions(text: string | undefined, documents: BaseDocument[]): string[] {
    if (!text) return [];

    const suggestions: string[] = [];
    const textLower = text.toLowerCase();

    // Suggest from document titles
    for (const document of documents) {
      if (document.title.toLowerCase().includes(textLower)) {
        suggestions.push(document.title);
      }
    }

    // Suggest from tags
    const allTags = new Set<string>();
    for (const document of documents) {
      for (const tag of document.metadata.tags) {
        if (tag.toLowerCase().includes(textLower)) {
          allTags.add(tag);
        }
      }
    }

    suggestions.push(...Array.from(allTags));

    return suggestions.slice(0, 10); // Limit to 10 suggestions
  }

  /**
   * Emit storage event
   */
  private emitStorageEvent(event: string, data: any): void {
    // In a real implementation, this would emit events to listeners
    console.log(`Storage event: ${event}`, data);
  }
}
