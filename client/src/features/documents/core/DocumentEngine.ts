import { BaseDocument, DocumentType, DocumentContent, DocumentMetadata, DocumentVersion, DocumentPermissions, CollaborationState, AIState, WorkflowState } from '../types/document.types';
import { DocumentRegistry } from './DocumentRegistry';
import { DocumentStorage } from './DocumentStorage';
import { DocumentVersioning } from './DocumentVersioning';
import { DocumentLocking } from './DocumentLocking';
import { DocumentLifecycle } from './DocumentLifecycle';
import { infographicDocumentType } from '../types/infographic/InfographicDocumentType';

/**
 * Core Document Engine - Central orchestrator for all document operations
 * 
 * This engine provides a unified interface for:
 * - Document CRUD operations
 * - Version control and history
 * - Collaboration and locking
 * - AI integration
 * - Workflow management
 * - Search and discovery
 */
export class DocumentEngine {
  private registry: DocumentRegistry;
  private storage: DocumentStorage;
  private versioning: DocumentVersioning;
  private locking: DocumentLocking;
  private lifecycle: DocumentLifecycle;

  constructor() {
    this.registry = new DocumentRegistry();
    this.storage = new DocumentStorage();
    this.versioning = new DocumentVersioning();
    this.locking = new DocumentLocking();
    this.lifecycle = new DocumentLifecycle();
    
    // Register document types
    this.registry.register('infographic', infographicDocumentType);
  }

  /**
   * Create a new document
   */
  async createDocument(
    type: DocumentType,
    data: Partial<BaseDocument>,
    options: {
      templateId?: string;
      aiGenerated?: boolean;
      creationMethod?: 'upload' | 'manual' | 'ai-generated' | 'hybrid';
    } = {}
  ): Promise<BaseDocument> {
    // Get document type definition
    const typeDefinition = this.registry.get(type);
    if (!typeDefinition) {
      throw new Error(`Unknown document type: ${type}`);
    }

    // Create base document structure
    const document: BaseDocument = {
      id: this.generateId(),
      type,
      title: data.title || 'Untitled Document',
      description: data.description || '',
      content: data.content || { format: 'json', data: {} },
      metadata: {
        category: data.metadata?.category || 'general',
        tags: data.metadata?.tags || [],
        status: 'draft',
        visibility: 'private',
        language: 'en',
        wordCount: 0,
        pageCount: 0,
        readingTime: 0,
        complexity: 'low',
        creationMethod: options.creationMethod || 'manual',
        ...data.metadata
      },
      version: {
        current: '1.0.0',
        history: [],
        locked: false
      },
      permissions: {
        owner: data.permissions?.owner || '',
        editors: data.permissions?.editors || [],
        viewers: data.permissions?.viewers || [],
        commenters: data.permissions?.commenters || [],
        public: false
      },
      collaboration: {
        activeUsers: [],
        comments: [],
        suggestions: [],
        mentions: [],
        lastActivity: new Date()
      },
      ai: {
        analyzed: false,
        overallScore: 0,
        qualityScore: 0,
        completenessScore: 0,
        readabilityScore: 0,
        insights: [],
        suggestions: [],
        autoGenerated: options.aiGenerated || false,
        aiAssisted: false,
        confidence: 0
      },
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: data.createdBy || '',
      lastModifiedBy: data.createdBy || ''
    };

    // Apply template if specified
    if (options.templateId) {
      const template = await this.getTemplate(options.templateId);
      if (template) {
        document.content = template.content;
        document.metadata = { ...document.metadata, ...template.metadata };
      }
    }

    // Validate document
    const validation = typeDefinition.validator(document);
    if (!validation.valid) {
      throw new Error(`Document validation failed: ${validation.errors.join(', ')}`);
    }

    // Save document
    await this.storage.save(document);

    // Initialize version history
    await this.versioning.createInitialVersion(document);

    // Initialize lifecycle
    await this.lifecycle.initialize(document);

    return document;
  }

  /**
   * Get a document by ID
   */
  async getDocument(id: string): Promise<BaseDocument | null> {
    return await this.storage.get(id);
  }

  /**
   * Update a document
   */
  async updateDocument(
    id: string,
    updates: Partial<BaseDocument>,
    options: {
      createVersion?: boolean;
      versionMessage?: string;
      lockDocument?: boolean;
    } = {}
  ): Promise<BaseDocument> {
    const document = await this.getDocument(id);
    if (!document) {
      throw new Error(`Document not found: ${id}`);
    }

    // Check if document is locked by another user
    if (document.version.locked && document.version.lockedBy !== updates.lastModifiedBy) {
      throw new Error('Document is locked by another user');
    }

    // Create new version if requested
    if (options.createVersion) {
      await this.versioning.createVersion(document, updates, options.versionMessage);
    }

    // Update document
    const updatedDocument = {
      ...document,
      ...updates,
      updatedAt: new Date(),
      lastModifiedBy: updates.lastModifiedBy || document.lastModifiedBy
    };

    // Validate updated document
    const typeDefinition = this.registry.get(updatedDocument.type);
    if (typeDefinition) {
      const validation = typeDefinition.validator(updatedDocument);
      if (!validation.valid) {
        throw new Error(`Document validation failed: ${validation.errors.join(', ')}`);
      }
    }

    // Save updated document
    await this.storage.save(updatedDocument);

    // Update lifecycle
    await this.lifecycle.update(updatedDocument);

    return updatedDocument;
  }

  /**
   * Delete a document
   */
  async deleteDocument(id: string, options: {
    permanent?: boolean;
    archive?: boolean;
  } = {}): Promise<void> {
    const document = await this.getDocument(id);
    if (!document) {
      throw new Error(`Document not found: ${id}`);
    }

    if (options.archive) {
      // Archive document instead of deleting
      await this.updateDocument(id, {
        metadata: { ...document.metadata, status: 'archived' }
      });
    } else if (options.permanent) {
      // Permanently delete document
      await this.storage.delete(id);
      await this.versioning.deleteHistory(id);
    } else {
      // Soft delete (mark as deleted)
      await this.updateDocument(id, {
        metadata: { ...document.metadata, status: 'deleted' }
      });
    }
  }

  /**
   * Search documents
   */
  async searchDocuments(query: {
    text?: string;
    type?: DocumentType;
    category?: string;
    tags?: string[];
    status?: string;
    createdBy?: string;
    dateRange?: { start: Date; end: Date };
    aiGenerated?: boolean;
    limit?: number;
    offset?: number;
  }): Promise<{ documents: BaseDocument[]; total: number }> {
    return await this.storage.search(query);
  }

  /**
   * Get document versions
   */
  async getDocumentVersions(id: string): Promise<any[]> {
    return await this.versioning.getHistory(id);
  }

  /**
   * Restore document to a specific version
   */
  async restoreDocument(id: string, version: string): Promise<BaseDocument> {
    const document = await this.getDocument(id);
    if (!document) {
      throw new Error(`Document not found: ${id}`);
    }

    const versionData = await this.versioning.getVersion(id, version);
    if (!versionData) {
      throw new Error(`Version not found: ${version}`);
    }

    // Create new version with restored content
    const restoredDocument = {
      ...document,
      content: versionData.snapshot.content,
      metadata: versionData.snapshot.metadata,
      version: {
        ...document.version,
        current: this.incrementVersion(document.version.current)
      }
    };

    return await this.updateDocument(id, restoredDocument, {
      createVersion: true,
      versionMessage: `Restored to version ${version}`
    });
  }

  /**
   * Lock document for editing
   */
  async lockDocument(id: string, userId: string): Promise<void> {
    await this.locking.lock(id, userId);
  }

  /**
   * Unlock document
   */
  async unlockDocument(id: string, userId: string): Promise<void> {
    await this.locking.unlock(id, userId);
  }

  /**
   * Get document templates
   */
  async getTemplates(type?: DocumentType): Promise<any[]> {
    return await this.storage.getTemplates(type);
  }

  /**
   * Get template by ID
   */
  async getTemplate(templateId: string): Promise<any> {
    return await this.storage.getTemplate(templateId);
  }

  /**
   * Analyze document with AI
   */
  async analyzeDocument(id: string): Promise<AIState> {
    const document = await this.getDocument(id);
    if (!document) {
      throw new Error(`Document not found: ${id}`);
    }

    // This would integrate with the AI service layer
    // For now, return mock analysis
    const analysis: AIState = {
      analyzed: true,
      lastAnalyzed: new Date(),
      overallScore: Math.floor(Math.random() * 40) + 60, // 60-100
      qualityScore: Math.floor(Math.random() * 40) + 60,
      completenessScore: Math.floor(Math.random() * 40) + 60,
      readabilityScore: Math.floor(Math.random() * 40) + 60,
      insights: [],
      suggestions: [],
      autoGenerated: document.ai.autoGenerated,
      aiAssisted: document.ai.aiAssisted,
      confidence: Math.floor(Math.random() * 30) + 70 // 70-100
    };

    // Update document with analysis
    await this.updateDocument(id, { ai: analysis });

    return analysis;
  }

  /**
   * Generate document content with AI
   */
  async generateContent(
    type: DocumentType,
    prompt: string,
    options: {
      templateId?: string;
      context?: any;
    } = {}
  ): Promise<BaseDocument> {
    // This would integrate with the AI service layer
    // For now, create a basic document structure
    const content: DocumentContent = {
      format: 'json',
      data: {
        sections: [
          {
            id: 'introduction',
            title: 'Introduction',
            content: 'AI-generated content based on prompt'
          }
        ]
      }
    };

    return await this.createDocument(type, {
      title: 'AI Generated Document',
      content,
      ai: {
        analyzed: false,
        overallScore: 0,
        qualityScore: 0,
        completenessScore: 0,
        readabilityScore: 0,
        insights: [],
        suggestions: [],
        autoGenerated: true,
        aiAssisted: false,
        confidence: 0,
        generationPrompt: prompt
      }
    }, {
      aiGenerated: true,
      creationMethod: 'ai-generated'
    });
  }

  /**
   * Get document analytics
   */
  async getDocumentAnalytics(id: string): Promise<any> {
    const document = await this.getDocument(id);
    if (!document) {
      throw new Error(`Document not found: ${id}`);
    }

    return {
      views: 0, // Would track from analytics
      edits: document.version.history.length,
      collaborators: document.collaboration.activeUsers.length,
      comments: document.collaboration.comments.length,
      suggestions: document.collaboration.suggestions.length,
      lastActivity: document.collaboration.lastActivity,
      aiScore: document.ai.overallScore,
      completionRate: document.ai.completenessScore
    };
  }

  /**
   * Get registry instance
   */
  getRegistry(): DocumentRegistry {
    return this.registry;
  }

  /**
   * Get storage instance
   */
  getStorage(): DocumentStorage {
    return this.storage;
  }

  /**
   * Get versioning instance
   */
  getVersioning(): DocumentVersioning {
    return this.versioning;
  }

  /**
   * Get locking instance
   */
  getLocking(): DocumentLocking {
    return this.locking;
  }

  /**
   * Get lifecycle instance
   */
  getLifecycle(): DocumentLifecycle {
    return this.lifecycle;
  }

  /**
   * Generate unique ID
   */
  private generateId(): string {
    return `doc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Increment version number
   */
  private incrementVersion(version: string): string {
    const parts = version.split('.');
    const major = parseInt(parts[0]);
    const minor = parseInt(parts[1]);
    const patch = parseInt(parts[2]);
    return `${major}.${minor}.${patch + 1}`;
  }
}

// Export singleton instance
export const documentEngine = new DocumentEngine();
